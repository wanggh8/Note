{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. Introduction1. Introduction "},"Foundation/":{"url":"Foundation/","title":"Foundation","keywords":"","body":"1. Introduction1. Introduction "},"Foundation/GCD多线程.html":{"url":"Foundation/GCD多线程.html","title":"GCD多线程","keywords":"","body":"1. GCD 多线程1.1. Dispatch Queue1.1.1. dispatch_queue_create1.1.2. Main Dispatch Queue1.1.3. Global Dispatch Queue1.1.4. dispatch_set_target_queue1.1.5. dispatch_after1.1.6. dispatch_async1.1.7. dispatch_sync1.1.8. dispatch_barrier_async1.1.9. dispatch_barrier_sync1.1.10. dispatch_apply1.1.11. dispatch_suspend1.1.12. dispatch_resume1.1.13. dispatch_once1.1.14. Dispatch Semaphore1.2. Dispatch Group1.3. Dispatch I/O1.3.1. 获取当前队列 Label1. GCD 多线程 Grand Central Dispatch 1.1. Dispatch Queue 执行处理的等待队列，分为：Serial Dispatch Queue 和 Concurrent Dispatch Queue。 Dispatch Queue 种类 备注 Serial Dispatch Queue 等待现在执行中处理结束 Concurrent Dispatch Queue 不等待现在执行中处理解锁 1.1.1. dispatch_queue_create dispatch_queue_t serialDispatchQueue = dispatch_queue_create(\"com.example.serialDispatchQueue\", NULL); dispatch_queue_t concurrentDispatchQueue = dispatch_queue_create(\"com.example.concurrentDispatchQueue\", DISPATCH_QUEUE_CONCURRENT); iOS 6.0 或 macOS 10.8 之前需手动释放队列和保持队列，之后 GCD 对象已纳入 ARC 管理范围 dispatch_release(serialDispatchQueue); // 已废弃 dispatch_retain(concurrentDispatchQueue); // 已废弃 1.1.2. Main Dispatch Queue 主线程队列，追加到主线程的任务在主线程的 RunLoop 处理 1.1.3. Global Dispatch Queue Global Dispatch Queue 是所有应用程序都能使用的 Concurrent Dispatch Queue。Global Dispatch Queue 有 4 个执行优先级，分别为高优先级、默认优先级、低优先级和后台优先级。通过 XNU 内核管理的用于 Global Dispatch Queue 的线程，将各自使用的 Global Dispatch Queue 的执行优先级作为线程的执行优先级使用。在向 Global Dispatch Queue 追加处理时，应选择与处理内容对应的执行优先级的 Global Dispatch Queue。 1.1.4. dispatch_set_target_queue 1.1.5. dispatch_after 1.1.6. dispatch_async 1.1.7. dispatch_sync 1.1.8. dispatch_barrier_async 1.1.9. dispatch_barrier_sync 1.1.10. dispatch_apply 1.1.11. dispatch_suspend 1.1.12. dispatch_resume 1.1.13. dispatch_once 1.1.14. Dispatch Semaphore 1.2. Dispatch Group 1.3. Dispatch I/O 1.3.1. 获取当前队列 Label String(validatingUTF8: __dispatch_queue_get_label(nil)) "},"Foundation/AutoLayout自动布局.html":{"url":"Foundation/AutoLayout自动布局.html","title":"AutoLayout自动布局","keywords":"","body":"1. AutoLayout 自动布局1.1. NSLayoutConstraint1.2. NSLayoutAnchor1.2.1. 常用属性1.2.2. 更新约束1.2.3. 使用步骤1.2.4. 注意事项1.2.5. 使用示例1.3. Auto Layout 的生命周期1. AutoLayout 自动布局 Auto Layout 是由苹果公司提供的一个用于动态计算 UIView 及其子类的大小和位置的库。 Auto Layout 构建在 Cassowary 算法的基础之上，苹果公司在 iOS 6 系统时引入了 Auto Layout，在 iOS 9 发布时，苹果推出了更简洁语法的 NSLayoutAnchor。iOS 12 大幅度提升 Auto Layout 性能，使滑动屏幕时达到满帧。 1.1. NSLayoutConstraint 步骤和代码繁杂，除非兼容 iOS 9 以下，否则不建议使用。 1.2. NSLayoutAnchor 1.2.1. 常用属性 leadingAnchor trailingAnchor leftAnchor rightAnchor topAnchor bottomAnchor widthAnchor heightAnchor centerXAnchor centerYAnchor firstBaselineAnchor lastBaselineAnchor 参考 Apple Developer NSLayoutAnchor 1.2.2. 更新约束 setNeedsLayout: 告知页面需要更新，但是不会立刻开始更新。执行后会立刻调用 layoutSubviews。 layoutIfNeeded: 告知页面布局立刻更新。所以一般都会和 setNeedsLayout 一起使用。如果希望立刻生成新的 frame 需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。 layoutSubviews: 更新子 View 约束 setNeedsUpdateConstraints: 需要更新约束，但是不会立刻开始 updateConstraintsIfNeeded: 立刻更新约束 updateConstraints: 更新 View 约束 1.2.3. 使用步骤 在使用 NSLayoutAnchor 为视图添加约束时一定要先把 translatesAutoresizingMaskIntoConstraints 设置 false 在使用 safeAreaLayoutGuide 适配 iPhone X 等机型时要对 iOS 11 之前的系统做适配，否则会导致低版本系统上程序 Crash 设置约束后要将其激活，即设置 active 为 true 可选 设置宽高比，设置 multiplier 为相应比例 1.2.4. 注意事项 leadingAnchor 与 leftAnchor、trailingAnchor 与 rightAnchor 不允许混用。在编译时不会出现任何问题，但是在运行时就会报错，并会导致程序 Crash 1.2.5. 使用示例 UIView *parentView = [[UIView alloc] init]; UIView *childView = [[UIView alloc] init]; [parentView addSubview:childView]; childView.translatesAutoresizingMaskIntoConstraints = NO; [childView.centerXAnchor constraintEqualToAnchor:parentView.centerXAnchor].active = YES; [childView.centerYAnchor constraintEqualToAnchor:parentView.centerYAnchor].active = YES; [childView.widthAnchor constraintEqualToConstant:100].active = YES; [childView.heightAnchor constraintEqualToConstant:100].active = YES; 1.3. Auto Layout 的生命周期 苹果的 Auto Layout 是基于 Cassowary 算法的，苹果在此基础上提供了一套 Layout Engine 引擎，由它来管理页面的布局，来完成创建、更新、销毁等。 在 APP 启动后，会开启一个常驻线程来监听约束变化，当约束发生变化后会出发 Deffered Layout Pass(延迟布局传递)，在里面做容错处理（如有些视图在更新约束时没有确定或缺失布局申明），完成后进入约束监听变化的状态。 当下一次刷新视图（如调用 layoutIfNeeded()）时，Layout Engine 会从上到下调用 layoutSubviews()，然后通过 Cassowary 算法计算各个子视图的大小和位置，算出来后将子视图的 frame 从 layout Engine 里拷贝出来，在之后的处理就和手写 frame 的绘制、渲染的过程一样了。使用 Auto Layout 和手写 frame 多的工作就在布局计算上。 "},"Foundation/AppThinning.html":{"url":"Foundation/AppThinning.html","title":"App Thinning","keywords":"","body":"1. App Thinning1.1. 指令集架构1.1.1. iOS 设备支持的指令集1.1.2. macOS 设备支持的指令集　1.1.3. Architectures1.1.4. Valid Architectures　　1.1.5. Build Active Architecture Only:1.1.6. 可执行文件大小限制1.2. Swift1.2.1. Swift 标准库1.3. 参考1. App Thinning 包体积大小优化 1.1. 指令集架构 1.1.1. iOS 设备支持的指令集 armv6: 　　iPhone, iPhone 3G, iPod 1G/2G armv7: 　　iPhone 3GS, iPhone 4, iPhone 4S, iPod 3G/4G/5G, iPad, iPad 2, iPad 3, iPad Mini armv7s： 　　 iPhone 5, iPhone 5c, iPad 4 arm64: 　　iPhone X，iPhone 8(Plus)，iPhone 7(Plus)，iPhone 6(Plus)，iPhone 6s(Plus), iPhone 5s, iPad Air(2), Retina iPad Mini(2,3) arm64e: 　　iPhone XS\\XR\\XS Max 　　 1.1.2. macOS 设备支持的指令集　 x86_64 和 arm64 1.1.3. Architectures 指定工程被编译成支持哪些指令集类型，而支持的指令集越多，就会编译出很多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包越大。　 1.1.4. Valid Architectures　　 该编译项指定可能支持的指令集，该列表和Architectures列表的交集，将是Xcode最终生成二进制包所支持的指令集。 　　比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：arm64，这时Xcode只会生成一个arm64指令集的二进制包。 　　减少安装包中的指令集数据包可以减小打包ipa的大小。　　 　　 1.1.5. Build Active Architecture Only: 默认Debug的时候设置为YES，Release的时候设置为NO。设置为YES是只编译当前的architecture版本，生成的包只包含当前连接设备的指令集代码。设置为NO，则生成的包包含所有的指令集代码（上面的Valid Architectures跟Architectures的交集）。因此为了调试速度更快，则Debug应该设置为YES。 1.1.6. 可执行文件大小限制 根据最大构建版本文件大小描述，苹果对可执行文件大小有明确限制，超过该限制会导致 App 审核被拒。具体限制如下： iOS 7 之前，二进制文件中所有的 __TEXT 段总和不得超过 80 MB iOS 7.X 至 iOS 8.X ，二进制文件中，每个特定架构中的 __TEXT 段不得超过 60 MB iOS 9.0 之后，二进制文件中所有的 __TEXT 段总和不得超过 500 MB 1.2. Swift 1.2.1. Swift 标准库 Swift 标准库在打包动态库时，会完整放到 Frameworks 文件夹下 打包架构包含: armv7、armv7s、arm64、arm64e 压缩前共计 151.1 MB 压缩后共计 65.2 MB 预计对 App 影响：包体增大 65.2 MB 在将动态库打包进 App 工程时，XcodeBuild 会对 Swift 标准库进行优化， strip 掉未使用的符号，从而减少 Swift 标准库大小。打进 App 内的动态库包含的 Swift 标准库如下： 打包架构包含: armv7、armv7s、arm64 压缩前共计 40.4 MB 压缩后共计 12.6 MB 预计对 App 影响：包体增大 12.6 MB 从多架构，变成单架构支持的时候，非系统的动态库，会马上变成单架构，大小有明显的变化。而 Swift 标准库却保持不变。 Swift 标准库，在分发到具体设备的时候，是单架构 UniPack 解决方案 将动态库打进一个空壳 App，待Xcode优化后将ipa中动态库和Swift文件拷出并签名，打到目标ipa中 1.3. 参考 https://www.zybuluo.com/qidiandasheng/note/1662385 https://juejin.cn/post/6844904169938092045#heading-23 https://www.cnblogs.com/lulushen/p/8135269.html "},"Swift/":{"url":"Swift/","title":"Swift","keywords":"","body":"1. Introduction1. Introduction "},"Swift/Swift-Tips.html":{"url":"Swift/Swift-Tips.html","title":"Swift Tips","summary":"Swift Tips","keywords":"","body":"1.1. Swift 5.5 引入了新的语法和 API 来支持这些功能。在应用程序中，除了使用最新的 Swift 版本外，还需要针对某些平台版本：1.2. ‘FrameworkName’ is not a member type of ‘FrameworkName’ errors inside swiftinterface1.2.1. 参考1.1. Swift 5.5 引入了新的语法和 API 来支持这些功能。在应用程序中，除了使用最新的 Swift 版本外，还需要针对某些平台版本： 如果使用的是 Xcode 13.2 或更高版本，它会将新的并发运行时与应用程序捆绑在一起，这样就可以将 iOS 13 和 macOS 10.15 作为最低的支持版本（对于本地应用程序）。 如果使用的是 Xcode 13，但版本低于 13.2，那么只能把 iOS 15 或 macOS 12（或更高版本）作为最低的支持版本。 1.2. ‘FrameworkName’ is not a member type of ‘FrameworkName’ errors inside swiftinterface XCFramework 下类名和模块名重复时，报错。这是 xcframework 已知问题，后续 Apple 可能会修复。 目前快速解决方案： 在 xcframework 所在文件夹打开命令行终端 执行以下命令（替换 frameworkName 字段）： find . -name \"*.swiftinterface\" -exec sed -i -e 's/frameworkName\\.//g' {} \\; 清理工程，重新编译 1.2.1. 参考 https://forums.swift.org/t/frameworkname-is-not-a-member-type-of-frameworkname-errors-inside-swiftinterface/28962 https://stackoverflow.com/questions/34159442/x-is-not-a-member-type-of-y "},"Swift/Swift第三方库.html":{"url":"Swift/Swift第三方库.html","title":"Swift第三方库","keywords":"","body":"1. Swift 第三方库1.1. Alamofire1.2. Kingfisher1.3. MonkeyKing1.4. SwiftyJSON1.5. SnapKit1.6. XLPagerTabStrip1. Swift 第三方库 Swift 第三方开源库总结 1.1. Alamofire Alamofire is an HTTP networking library written in Swift. 项目地址：https://github.com/Alamofire/Alamofire Carthage 引入： github \"Alamofire/Alamofire\" 1.2. Kingfisher Kingfisher is a powerful, pure-Swift library for downloading and caching images from the web. It provides you a chance to use a pure-Swift way to work with remote images in your next app. 项目地址：https://github.com/onevcat/Kingfisher Carthage 引入： github \"onevcat/Kingfisher\" 1.3. MonkeyKing onkeyKing helps you post SNS messages to Chinese Social Networks, without their buggy SDKs. MonkeyKing uses the same analysis process of openshare. We also use some reverse engineering tools such as Hopper Disassembler to unveil several undocumented authentication mechanisms under the hood. It supports sharing Text, URL, Image, Audio, Video, and File to WeChat, QQ, Alipay or Weibo. MonkeyKing can also post messages to Weibo by a web page. (Note: Audio and Video are exclusive to WeChat or QQ, and File is exclusive to QQ Dataline) MonkeyKing also supports OAuth and Mobile payment via WeChat and Alipay! 项目地址：https://github.com/nixzhu/MonkeyKing Carthage 引入： github \"nixzhu/MonkeyKing\" 1.4. SwiftyJSON SwiftyJSON makes it easy to deal with JSON data in Swift. 项目地址：https://github.com/SwiftyJSON/SwiftyJSON Carthage 引入： github \"SwiftyJSON/SwiftyJSON\" 1.5. SnapKit SnapKit is a DSL to make Auto Layout easy on both iOS and OS X. 项目地址：https://github.com/SnapKit/SnapKit Carthage 引入： github \"SnapKit/SnapKit\" 1.6. XLPagerTabStrip Android PagerTabStrip for iOS. 项目地址：https://github.com/xmartlabs/XLPagerTabStrip "},"Swift/Swift内存管理.html":{"url":"Swift/Swift内存管理.html","title":"内存管理","summary":"Swift 内存管理相关","keywords":"","body":"1. Swift 内存管理1. Swift 内存管理 "},"Swift/闭包.html":{"url":"Swift/闭包.html","title":"闭包","summary":"Swift 闭包","keywords":"","body":"1. 闭包1.1. 自动闭包1. 闭包 1.1. 自动闭包 自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。 自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用（Side Effect）和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。 "},"Swift/字符串和字符.html":{"url":"Swift/字符串和字符.html","title":"字符串和字符","summary":"Swift 字符串和字符","keywords":"","body":"1. 字符串和字符1.1.1. StaticString1. 字符串和字符 1.1.1. StaticString 一种字符串类型，旨在表示在编译时已知的文本，StaticString 类型的实例是不可变的。 与 Swift 更常用的 String 类型不同，StaticString 仅提供对其内容的低级访问。静态字符串可以使用以下任一项作为其存储： 指向以空字符结尾的 UTF-8 代码单元序列的指针 在非常有限的情况下，单个 Unicode 标量值 "},"Swift/Swift-OC混编.html":{"url":"Swift/Swift-OC混编.html","title":"Swift OC 混编","keywords":"","body":"1. Swift OC 混编1.1. Q & A1. Swift OC 混编 1.1. Q & A Q: 在 framework 中，是没有办法使用这个桥接文件的，就算你生成了这个桥接文件，并且正确的配置了 Objective-C Bridging Header 路径，编译的时候会提示 “using bridging headers with framework targets is unsupported“ 错误。所以怎么在 Swift 中使用或者继承 Objective-C 文件呢？ A: 虽然不支持桥接文件，并且 Swift 也不可以直接继承或者使用 Objective-C 文件的，所以需要在 framework 的头文件（比如 framework 为 Sample.framework, 头文件即为 Sample.h）对 Objective-C 文件声明，然后设置权限为 Public，并且设置 Objective-C 文件头文件权限为 Public "},"SwiftUI/":{"url":"SwiftUI/","title":"SwiftUI","keywords":"","body":"1. Introduction1. Introduction Swift UI 相关 "},"SwiftUI/SwiftUI-Tips.html":{"url":"SwiftUI/SwiftUI-Tips.html","title":"SwiftUI Tips","summary":"SwiftUI Tips","keywords":"","body":"UIViewRepresentable 协议提供了在 SwiftUI 中封装 UIView 的功能 "},"ObjC/":{"url":"ObjC/","title":"Objective-C","keywords":"","body":"1. Introduction1. Introduction "},"ObjC/OC-Tips.html":{"url":"ObjC/OC-Tips.html","title":"ObjC Tips","summary":"Objective-C Tips","keywords":"","body":"1. Objective-C Tips1.1. Objective-C 基础1.1.1. 对象方法和类方法的区别?1.1.2. 什么是分类?1.1.3. 什么是协议?1.1.4. 为什么说OC是一门动态语言？1.1.5. 动态绑定1.1.6. cocoa touch底层技术架构?1.1.7. 什么是谓词?1.1.8. 什么是类工厂方法?1.1.9. Svn 和 Git 区别1.1.10. CocoaPods理解1.1.11. --verbose 和 --no-repo-update有什么用?1.1.12. 简要说明const,宏,static,extern区分以及使用?1.1.13. 编译型和解释型的区别?1.1.14. 动态语言和静态语言?1.1.15. 什么是指针常量和常量指针？1.1.16. 指针函数和函数指针1.1.17. 自定义宏 #define MIN(A,B) A1. Objective-C Tips 1.1. Objective-C 基础 1.1.1. 对象方法和类方法的区别? 对象方法：以减号开头,只可以被对象调用，可以访问成员变量 类方法：以加号开头只能用类名调用，对象不可以调用，类方法不能访问成员变量 1.1.2. 什么是分类? 分类: 在不修改原有类代码的情况下,可以给类添加方法 Categroy 给类扩展方法,或者关联属性, Categroy底层结构也是一个结构体:内部存储这结构体的名字,那个类的分类,以及对象和类方法列表,协议,属性信息 通过Runtime加载某个类的所有Category数据 把所有Category的方法、属性、协议数据，合并到一个大数组中后面参与编译的Category数据，会在数组的前面 将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面 1.1.3. 什么是协议? 协议：协议是一套标准，这个标准中声明了很多方法，但是不关心具体这些方法是怎么实现的，具体实现是由遵循这个协议的类去完成的。 在OC中，一个类可以实现多个协议，通过协议可以弥补单继承的缺陷但是协议跟继承不一样，协议只是一个方法列表，方法的实现得靠遵循这个协议的类去实现。 1.1.4. 为什么说OC是一门动态语言？ 动态语言:是指程序在运行时可以改变其结构，新的函数可以被引进,已有的函数可以被删除等在结构上的变化 动态类型语言: 就是类型的检查是在运行时做的。 OC的动态特性可从三方面: 动态类型（Dynamic typing）：最终判定该类的实例类型是在运行期间 动态绑定（Dynamic binding）：在运行时确定调用的方法 动态加载（Dynamic loading）：在运行期间加载需要的资源或可执行代码 1.1.5. 动态绑定 动态绑定 将调用方法的确定也推迟到运行时。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去，这就是动态绑定。 在编译时，方法的调用并不和代码绑定在一起，只有在消息发送出来之后，才确定被调用的代码。 1.1.6. cocoa touch底层技术架构? cocoa touch底层技术架构 主要分为4层: 可触摸层 Cocoa Touch : UI组件,触摸事件和事件驱动,系统接口 媒体层 Media: 音视频播放,动画,2D和3D图形 Core Server: 核心服务层,底层特性,文件,网络,位置服务区等 Core OS: 内存管理,底层网络,硬盘管理 1.1.7. 什么是谓词? 谓词(NSPredicate)是OC针对数据集合的一种逻辑帅选条件,类似一个过滤器,简单实实用代码如下: Person * p1 = [Person personWithName:@\"alex\" Age:20]; Person * p2 = [Person personWithName:@\"alex1\" Age:30]; Person * p3 = [Person personWithName:@\"alex2\" Age:10]; Person * p4 = [Person personWithName:@\"alex3\" Age:40]; Person * p5 = [Person personWithName:@\"alex4\" Age:80]; NSArray * persons = @[p1, p2, p3, p4, p5]; //定义谓词对象,谓词对象中包含了过滤条件 NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"age 1.1.8. 什么是类工厂方法? 类工厂方法就是用来快速创建对象的类方法, 他可以直接返回一个初始化好的对象,具备以下特征: 一定是类方法 返回值需要是 id/instancetype 类型 规范的方法名说说明类工厂方法返回的是一个什么对象,一般以类名首字母小写开始; 比如系统 UIButton 的buttonWithType 就是一个类工厂方法: // 类工厂方法 + (instancetype)buttonWithType:(UIButtonType)buttonType; // 使用 + UIButton * button = [UIButton buttonWithType:UIButtonTypeCustom]; 1.1.9. Svn 和 Git 区别 svn 和 git 都是用来对项目进行版本控制以及代码管理的.可以监测代码及资源的更改变化.有利于实现高效的团队合作; svn 是集中式的,集中式是指只有一个远程版本库,git 是分布式的,分布式有本地和远程版本库,本地仓库都保留了整个项目的完整备份; 如果存储远程版本库的服务器挂了，所有人的代码都无法提交，甚至丢失版本库, git则因为有本地版本库而不会有这个问题。 由于两者的架构不同,git 和 svn 的分支也是不同的, svn 的分支是一个完整的目录,包含所有的实际文件,和中心仓库是保持同步的,如果某个团队成员创建新的分支,那么会同步到所有的版本成员中,所有人都会收到影响. 而 git下创建的分支合并前是不会影响到任何人的.创建分支可以在本地脱机进行任何操作.测试无误后在合并到主分支,然后其他成员才可以看得到. 1.1.10. CocoaPods理解 CocoaPods 是一个 objc 的依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的 想深入了解这个命令执行的详细内容，可以在这个命令后面加上 --verbose。现在运行这个命令 pod install --verbose CocoaPod三方库,会优先编译 1.1.11. --verbose 和 --no-repo-update有什么用? verbose意思为 冗长的、啰嗦的，一般在程序中表示详细信息。此参数可以显示命令执行过程中都发生了什么。 pod install或pod update可能会卡在Analyzing dependencies步骤，因为这两个命令会升级 CocoaPods 的 spec 仓库，追加该参数可以省略此步骤，命令执行速度会提升。 1.1.12. 简要说明const,宏,static,extern区分以及使用? const const常量修饰符,经常使用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。 - const 作用：限制类型 - 使用const修饰基本变量, 两种写法效果一致 , b都是只读变量 const int b = 5; int const b = 5; - 使用const修饰指针变量的变量 第一种: const int *p = &a 和 int const *q = &a; 效果一致,*p 的值不能改,p 的指向可以改; 第二种: int * const p = &a; 表示 p 的指向不能改,*p 的值可以改 第三种: const int * const p = &a; *p 值和 p 的指向都不能改 const 在*左边, 指向可变, 值不可变 const 在*的右边, 指向不可变, 值可变 const 在*的两边, 都不可变 宏 * 基本概念：宏是一种批量处理的称谓。一般说来，宏是一种规则或模式，或称语法替换 ，用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串)。这种替换在预编译时进行，称作宏展开。编译器会在编译前扫描代码，如果遇到我们已经定义好的宏那么就会进行代码替换，宏只会在内存中copy一份，然后全局替换，宏一般分为对象宏和函数宏。 宏的弊端：如果代码中大量的使用宏会使预编译时间变长。 const与宏的区别？ * 编译检查 宏没有编译检查，const有编译检查； * 宏的好处 定义函数，方法 const不可以； * 宏的坏处 大量使用宏，会导致预编译时间过长 static * 修饰局部变量: 被static修饰局部变量，延长生命周期，跟整个应用程序有关，程序结束才会销毁,被 static 修饰局部变量，只会分配一次内存 * 修饰全局变量: 被static修饰全局变量，作用域会修改，也就是只能在当前文件下使用 extern 声明外部全局变量(只能用于声明，不能用于定义) 常用用法（.h结合extern联合使用） 如果在.h文件中声明了extern全局变量，那么在同一个类中的.m文件对全局变量的赋值必须是：数据类型+变量名（与声明一致）=XXXX结构。并且在调用的时候，必须导入.h文件。代码如下： .h @interface ExternModel : NSObject extern NSString *lhString; @end .m @implementation ExternModel NSString *lhString=@\"hello\"; @end 调用的时候：例如：在viewController.m中调用，则可以引入：ExternModel.h，否则无法识别全局变量。当然也可以通过不导入头文件的方式进行调用（通过extern调用）。 1.1.13. 编译型和解释型的区别? 编译型语言: 首先是将源代码编译生成机器指令，再由机器运行机器码 (二进制)。 解释型语言: 源代码不是直接翻译成机器指令，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。 1.1.14. 动态语言和静态语言? 动态类型语言: 是指数据类型的检查是在运行时做的。用动态类型语言编程时，不用给变量指定数据类型，该语言会在你第一次赋值给变量时，在内部记录数据类型。 静态类型语言: 是指数据类型的检查是在运行前（如编译阶段）做的。 1.1.15. 什么是指针常量和常量指针？ 指针常量——指针类型的常量（int *const p） 本质上一个常量，指针用来说明常量的类型，表示该常量是一个指针类型的常量。在指针常量中，指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化。用法如下： int a = 10, b = 20; int * const p = &a; *p = 30; // p指向的地址是一定的，但其内容可以修改 常量指针——指向“常量”的指针（const int p， int const p） 常量指针本质上是一个指针，常量表示指针指向的内容，说明该指针指向一个“常量”。在常量指针中，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。用法如下： int a = 10, b = 20; const int *p = &a; p = &b; // 指针可以指向其他地址，但是内容不可以改变 1.1.16. 指针函数和函数指针 指针函数 指针函数： 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。 // 指针函数 int *sum(int a, int b){ int result = a + b; int *c = &result; return c; } int *p = sum(10, 20); printf(\"sum:%d\\n\", *p); 函数指针 与指针函数不同，函数指针 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。 // 函数指针 int max(int a, int b){ return (a > b)?a:b; } int (*p)(int, int) = max; int result = p(10, 20); printf(\"result:%d\\n\", result); 1.1.17. 自定义宏 #define MIN(A,B) A float a = 1; float b = MIN(a++,1.5); 问 a= ? b = ? 答案: a = 3; b = 2 a++ 会后执行, a++在表达式出现了2次,得3, a++b?a:b; } 运行 a = 2; b =1.5; "},"ObjC/OC基础.html":{"url":"ObjC/OC基础.html","title":"基础","summary":"Objective-C Manual","keywords":"","body":"1. Objective-C 基础2. import选项和#include选项完全相同，＃import只是它可以确保相同的文件只会被包含一次。2.1. 基础2.1.1. 程序结构2.1.2. 基本语法2.2. 高级部分2.2.1. 类与对象2.2.2. 继承与多态2.2.3. 类别、类拓展2.2.4. 协议2.2.5. 内存管理1. Objective-C 基础 Object-C通常写作Objective-C或者Obj-C或OC，是根据C语言所衍生出来的语言，继承了C语言的特性，是扩充C的面向对象编程语言。它主要使用于Mac OS X和IOS系统。Objective-C是非常“实际”的语言。它使用一个用C写成、很小的运行库，只会令应用程序的大小增加很小。目前apple绝大多数采用的是Object-C。 Objective-C代码的文件扩展名 .h头文件。头文件包含类，类型，函数和常数的声明。 .m源代码文件。这是典型的源代码文件扩展名，可以包含Objective-C和C代码。 .mm源代码文件。带有这种扩展名的源代码文件，除了可以包含Objective-C和C代码以外还可以包含C++代码。仅在你的Objective-C代码中确实需要使用C++类或者特性的时候才用这种扩展名。 2. import选项和#include选项完全相同，＃import只是它可以确保相同的文件只会被包含一次。 2.1. 基础 2.1.1. 程序结构 预处理程序命令 #import 接口 @interface name:NSObject /n内容/n @end 实现 @implement name /n内容/n @end 方法 - (返回类型)name; -(返回类型)name{} 变量 声明和表达 注释 /*...*/或// 2.1.2. 基本语法 关键字 auto else long switch break enum register typedef case extern return union char float shorsst unsigned const for signed void continue goto sizeof volatile default if static while do int struct _Packed double protocol interface implementation NSObject NSInteger NSNumber CGFloat property nonatomic retain strong weak unsafe_unretained readwrite readonly 基本类型与框架 标量类型（非对象）：int、float、char、BOOL、NSInteger、NSUInteger、CGFloat 基本类型有多种方式转化为引用类型 NSString和基本类型的互转 NSNumber和基本类型的互转 NSValue和复杂结构体的互转 NSString和CString的互转 字符编码 NSData NSMutableData NSNumber NSArray/NSMutableArray NSDictionary/NSMutableDictionary NSSet/NSMutableSet NSOrderedSet/NSMutableOrderedSet Foundation框架 定义了Objective-C类的基础层。 除了提供一组有用的原始对象类之外，它还引入了几个定义Objective-C语言未涵盖的功能的范例。使用#import 之类的东西来导入Objective-C类，为了避免手写导入的类太多，使用#import 导入 提供一小组基本实用程序类。 通过为解除分配等事项引入一致的约定，使软件开发更容易。 支持Unicode字符串，对象持久性和对象分发。 提供一定程度的操作系统独立性以增强可移植性。 数据存储 NSArray，NSDictionary和NSSet为Objective-C任何类的对象提供存储。 文本和字符串 NSCharacterSet表示NSString和NSScanner类使用的各种字符分组。NSString类表示文本字符串，并提供搜索，组合和比较字符串的方法。 NSScanner对象用于扫描NSString对象中的数字和单词。 日期和时间 NSDate，NSTimeZone和NSCalendar类存储时间和日期并表示日历信息。它们提供了计算日期和时间差异的方法。它们与NSLocale一起提供了以多种格式显示日期和时间以及根据世界中的位置调整时间和日期的方法。 异常处理 异常处理用于处理意外情况，它在Objective-C中提供NSException类对象。 文件处理 文件处理是在NSFileManager类的帮助下完成的。 URL加载系统 一组提供对常见Internet协议访问的类和协议。 方法 一般定义形式： -(return_type)method_name:(argumentType1 )argumentName1 joiningArgument2:(argumentType2 )argumentName2 ...joiningArgumentn:(argumentTypen )argumentNamen {body of the function} 返回类型- 方法可以返回值。return_type是函数返回的值的数据类型。 某些方法执行所需的操作而不返回值。 在这种情况下，return_type是关键字void。 方法名称- 这是方法的名称。方法名称和参数列表一起构成方法签名。 参数- 调用函数时，将值传递给参数。参数列表指的是方法的参数的类型，顺序和数量。参数是可选的。按值调用：将参数的实际值复制到函数的形式参数中，对函数内部参数所做的更改不会对参数产生影响。 按引用调用将参数的地址复制到形式参数中。在函数内部，该地址用于访问调用中使用的实际参数。对参数所做的更改会影响参数。 连接参数- 一个连接的参数是让它更易于阅读并在调用时清楚地表达它。 方法体- 方法体包含一组语句用于定义方法的作用。 代码块 块定义了一个将数据与相关行为相结合的对象，块是Objective-C对象，因此它们可以添加到NSArray或NSDictionary等集合中。 它们还能够从封闭范围中捕获值，使其类似于其他编程语言中的闭包或lambda。一般形式： (^blockname)(list of arguments);//定义 //实现 (^blockname)(list of arguments) = ^(arguments){ body; };//有参数 void (^theBlock)(void) = ^{ printf(\"Hello Blocks!\\n\"); };//无参数 //例子 double (^multiplyTwoValues)(double, double) = ^(double firstValue, double secondValue) { return firstValue * secondValue; }; block属性 block用于循环 block用于异步任务 block常见的内存泄露场景 数组、字符串、指针 //数组声明 type arrayName [ arraySize ]; type name[size1][size2]...[sizeN];//多维数组 //初始化数组 double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0}; //访问数组 double salary = balance[9]; //快速枚举遍历数组 for (classType variable in collectionObject ) { statements } //快速枚举向后 for (classType variable in [collectionObject reverseObjectEnumerator] ) { statements } //指针递增递减 ptr++ ptr--; //指针比较 如果p1和p2指向彼此相关的变量，例如同一数组的元素，则可以有意义地比较指针 ptr 结构体 struct [structure tag] { member definition; member definition; ... member definition; } [one or more structure variables]; 错误处理 NSString *domain = @\"com.yiibai.MyApplication.ErrorDomain\"; NSString *desc = NSLocalizedString(@\"Unable to complete the process\", @\"\"); NSDictionary *userInfo = @{ NSLocalizedDescriptionKey : desc }; NSError *error = [NSError errorWithDomain:domain code:-101 userInfo:userInfo]; 2.2. 高级部分 2.2.1. 类与对象 Objective-C特征 类定义在两个不同的部分，即@interface和@implementation。 几乎所有东西都是对象的形式。 对象接收消息，对象通常称为接收者。 对象包含实例变量。 对象和实例变量具有范围。 类隐藏对象的实现。 属性用于提供用于其他类对此类实例变量的访问。 类定义实现 类定义以关键字@interface开头，后跟接口(类)名称; 和一个由一对花括号括起来的类体。 在Objective-C中，所有类都派生自名为NSObject的基类。 它是所有Objective-C类的超类。 它提供了内存分配和初始化等基本方法。 例如： @interface Box:NSObject { //实例变量 double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box } @property(nonatomic, readwrite) double height; // Property @end @implementation Box @synthesize height; -(id)init { self = [super init]; length = 1.0; breadth = 1.0; return self; } -(double) volume { return length*breadth*height; } @end 类初始化和访问 Box box1 = [[Box alloc]init]; box1.height = 15.0 属性 在Objective-C中引入了属性，以确保可以在类外部访问类的实例变量，只有属性才能访问类的实例变量。 实际上，为属性创建了内部getter和setter方法。 属性以@property开头，它是一个关键字 接下来是访问说明符，它们是非原子，读写或只读，强，不安全或不完整。 这取决于变量的类型。 对于任何指针类型，可以使用strong，unsafe_unretained或weak。 类似地，对于其他类型，可以使用readwrite或readonly。 接下来是变量的数据类型。 最后，将属性名称以分号结束。 在实现类中添加synthesize语句。 但是在最新的XCode中，合成部分由XCode处理，不需要包含synthesize语句。 @synthesize 该关键字指定了属性的实例变量名称，并且根据存储语义（readwrite、readonly）系统自动合成setter和getter方法，当然也可以手写来覆盖系统提供的。 @dynamic 该关键字告诉编译器不要为我合成setter和getter方法，这些方法将由我自己实现。当然我们可以不实现这在编译阶段不会出现问题，直到运行时才会检查是否实现了setter和getter，如果没有实现就会抛出异常。 属性的特质： 1.原子性： 　　原子性就是指该属性是否为同步的，OC中大部分属性都是nonatomic（非原子性）的，如果不写nonatomic那么就会是原子性的。理论上来说原子性属性的读写都将会是同步的，但是OC中atomic并不能一定确定属性为同步的，如果真要进行同步操作，还要用更加深层次的同步锁API。而且atomic会很影响效率，所以一般都会写nonatomic。 2.读/写权限： 　　读写为readonly和readwrite两种，前一种在系统只会合成getter方法，而后一种则会同时生成setter和getter。如果属性设置为了readonly属性，那么该属性是不可以修改的。 3.内存管理语义： 　　assign：该方法只会针对“纯量类型”(CGFloat或NSInteger等)的简单赋值操作，id类型也要用assign，所以一般iOS中的代理delegate属性都会用assign来标示，如： @property (nonatomic, assign) id dataSource; @property (nonatomic, assign) id delegate; 　　strong: 使用该特性实例变量在赋值时，会释放旧值同时设置新值，对对象产生一个强引用，用MRC来说就是引用计数+1。 　　weak: 属性表明了一种”非拥有关系“，既不释放旧值，也不保留新值。用MRC就是引用计数不变，当指向的对象被释放时，该属性自动被设置为nil。这里多说一点，weak的runtime实现是通过hash表完成的，用变量名做键，一旦发现属性所指的对象被释放了，立刻设置为nil。 　　unsafe_unretained：和weak一样，唯一的区别就是当对象被释放后，该属性不会被设置为nil。所以是unsafe的。 　　copy：和strong类似，不过该属性会被复制一个新的副本。很多时使用copy是为了方式Mutable（可变类型）在我们不知道的情况下修改了属性值，而用copy可以生成一个不可变的副本防止被修改。如果我们自己实现setter方法的话，需要手动copy。 4.方法名：方法名可以修改为我们合成的方法名，可以使存取方法语义更加符合应用场景。　 getter = setter = 2.2.2. 继承与多态 继承 Objective-C只允许多级继承，即它只能有一个基类但允许多级继承。 Objective-C中的所有类都派生自超类NSObject。 @interfacederived-class:base-class 如果派生类在接口类中定义，则它可以访问其基类的所有私有成员，但它不能访问在实现文件中定义的私有成员。派生类继承所有基类在声明中方法和变量 多态 Objective-C多态表示对成员函数的调用将导致执行不同的函数，具体取决于调用该函数的对象的类型。在使用多态是，会进行动态检测，以调用真实的对象方法。多态在代码中的体现即父类指针指向子类对象。子类必须重写父类的方法 好处：如果函数方法参数中使用的是父类类型，则可以传入父类和子类对象，而不用再去定义多个函数来和相应的类进行匹配了。 局限性：父类类型的变量不能直接调用子类特有的方法，如果必须要调用，则必须强制转换为子类特有的方法。 代码例子： @interface Shape : NSObject { CGFloat area; } - (void)printArea; - (void)calculateArea; @end @implementation Shape - (void)printArea { NSLog(@\"The area is %f\", area); } - (void)calculateArea { } @end @interface Square : Shape { CGFloat length; } - (id)initWithSide:(CGFloat)side; - (void)calculateArea; @end @implementation Square - (id)initWithSide:(CGFloat)side { length = side; return self; } - (void)calculateArea { area = length * length; } - (void)printArea { NSLog(@\"The area of square is %f\", area); } @end @interface Rectangle : Shape { CGFloat length; CGFloat breadth; } - (id)initWithLength:(CGFloat)rLength andBreadth:(CGFloat)rBreadth; @end @implementation Rectangle - (id)initWithLength:(CGFloat)rLength andBreadth:(CGFloat)rBreadth { length = rLength; breadth = rBreadth; return self; } - (void)calculateArea { area = length * breadth; } @end int main(int argc, const char * argv[]) { NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init]; Shape *square = [[Square alloc]initWithSide:10.0]; [square calculateArea]; [square printArea]; Shape *rect = [[Rectangle alloc] initWithLength:10.0 andBreadth:5.0]; [rect calculateArea]; [rect printArea]; [pool drain]; return 0; } //output 2018-11-16 02:02:22.096 main[159689] The area of square is 100.000000 2018-11-16 02:02:22.098 main[159689] The area is 50.000000 2.2.3. 类别、类拓展 类别Category 常用于给已知的类（Class）增加行为，注意类别会有隐式重名冲突的问题。当你已经封装好了一个类（也可能是系统类、第三方库），不想在改动这个类了，可是随着程序功能的增加需要在类中增加一个方法，这时我们不必修改主类，只需要给你原来的类增加一个分类。将一个大型的类拆分成不同的分类，在不同分类中实现类别声明的方法，这样可以将一个类的实现写到多个.m文件中，方便管理和协同开发。分类中的方法可以只声明，不实现，所以在协议不支持可选方法的时候（协议现在已经支持可选方法），通常把分类作为非正式协议使用。添加属性和成员变量的一种常见的办法是通过runtime.h中objc_getAssociatedObject / objc_setAssociatedObject来访问和生成关联对象。通过这种方法来模拟生成属性。 @interface XYZPerson (XYZPersonNameDisplayAdditions) -(NSString *)lastNameFirstNameString; @end 分类中方法的优先级比原来类中的方法高，也就是说，在分类中重写了原来类中的方法，那么分类中的方法会覆盖原来类中的方法 分类中只能声明方法，不能添加属性变量，在运行时分类中的方法与主类中的方法没有区别。 通常来讲，分类定义在.h文件中，但也可以定义.m文件中，此时分类的方法就变成私有方法 拓展Extension 扩展是分类的一种特殊形式。拓展作用： 1.能为某个类附加额外的属性，成员变量，方法声明 2.一般的将类扩展直接写在.m文件中，而不单独建立类扩展文件 3.一般的私有属性和方法写到类扩展 4.和类别相似，但是小括号里面没有扩展的名字，就像匿名的类别 @interface 主类类名（） @end 扩展通常定义在主类.m文件中，扩展中声明的方法直接在主类.m文件中实现。 局限性： 不能为任何类声明扩展，仅适用于原始实现源代码的类。 扩展是添加仅特定于类的私有方法和私有变量。 扩展内部声明的任何方法或变量即使对于继承的类也是不可访问的。 类别和扩展的区别 需不需要源码 能不能增加属性 分类是不可以声明实例变量，通常是公开的，文件名是：主类名+分类名.h 扩展是可以声明实例变量，是私有的，文件名为：主类名_扩展标识.h，在主类的.m文件中#import该头文件 2.2.4. 协议 protocol协议的基本用途： 可以用来声明一大堆方法（不能声明成员变量） 只要某个类遵守了这个协议，就相当于拥有了这个协议中的所有方法声明。 只要父类遵守了某个协议，就相当于子类也遵守了。 注意：协议内仅仅写方法声明，不能写实现，不能写成员变量 对协议的简单理解： protocol声明的方法可以交给任何类去实现。 protocol的作用仅仅就是声明方法，所以新建协议就是.h文件。 @protocol关键字表示声明协议，同样以@end结尾。例如：@protocol MyProtocol@end @protocol声明的方法要交给类去实现，即类遵守协议。也就是说只要类遵守了这个协议，就相当于拥有了这个协议内的所有方法声明。（协议仅仅用来声明方法，以交给多个类去实现（去遵守）） 协议与分类一样只能写方法，不能声明成员变量。但是和分类不同的是协议只能写方法声明，分类是给某个类扩充一些方法 协议遵守协议 （1）一个类可以继承别的类，同样协议也可以遵守协议。 （2）一个协议可以遵守多个协议，多个协议之间用逗号隔开 （3）一个协议遵守了其他协议，就相当于拥有了其他协议中的所有方法声明。 1> 类遵守协议 @interface 类名：父类名 @end; 2> 协议遵守协议 @protocol 协议名称 //方法声明列表,,,, @end 3> 协议中方法声明的关键字 1>@required（默认） 要求实现，若没实现，将出现警告。 2>@optional 不要求实现，实不实现都不会有警告。 2.2.5. 内存管理 Objective-C内存管理技术大致可分为两类 - “手动保留或释放”或MRR “自动参考计数”或ARC 在MRR中，通过跟踪自己的对象来明确管理内存。这是使用一个称为引用计数的模型实现的，Foundation类NSObject与运行时环境一起提供。MRR和ARC之间的唯一区别是保留和释放，前者是手动处理，而后者则自动处理。 MRR基本规则 拥有创建的任何对象：使用名称以“alloc”，“new”，“copy”或“mutableCopy”开头的方法创建对象 使用retain获取对象的所有权：通常保证接收到的对象在接收到的方法中保持有效，并且该方法也可以安全地将对象返回给它的调用者。在两种情况下使用retain- 在访问器方法或init方法的实现中，获取想要存储为对象属性值的对象的所有权。 防止对象因某些其他操作的副作用而失效。 当不再需要它时，必须放弃对拥有的对象的所有权：通过向对象发送释放消息或自动释放消息来放弃对象的所有权。 因此，在Cocoa术语中，放弃对象的所有权通常被称为“释放”对象。 不得放弃不拥有的对象的所有权。 “自动参考计数”或ARC 在自动引用计数或ARC中，系统使用与MRR相同的引用计数系统，但它在编译时为我们插入适当的内存管理方法调用。 强烈建议将ARC用于新项目。 如果使用ARC，通常不需要理解本文档中描述的底层实现，尽管在某些情况下它可能会有所帮助。 如上所述，在ARC中，不需要添加release和retain方法，因为编译器会对此进行处理。 实际上，Objective-C的基本过程仍然是相同的。 它在内部使用保留和释放操作，使开发人员更容易编码而无需担心这些操作，这将减少写入的代码量和内存泄漏的可能性。 还有另一个原则叫做垃圾收集，它在Mac OS-X中与MRR一起使用，但由于它在OS-X Mountain Lion中的弃用，它还没有与MRR一起讨论过。 此外，iOS对象从未拥有垃圾收集功能。 使用ARC，OS-X中也没有使用垃圾收集。 "},"ObjC/OC块.html":{"url":"ObjC/OC块.html","title":"块","summary":"Objective-C Block 块","keywords":"","body":"1. Block 块1.1. 简介1.2. 实现1.3. 注意事项1. Block 块 1.1. 简介 1.2. 实现 1.3. 注意事项 截获自动变量的方法没有实现对C语言数组的捕获，使用指针替代可解决 typedef void (^Blk)(void); // 截获自动变量的方法没有实现对C语言数组的捕获 // 使用指针替代可解决 // const char text[] = \"hello\"; const char *text = \"hello\"; Blk blk3 = ^{ printf(\"%c\\n\", text[2]); }; blk3(); 测试2 "},"ObjC/OC内存管理.html":{"url":"ObjC/OC内存管理.html","title":"内存管理","summary":"Objective-C 内存管理相关","keywords":"","body":"1. Objective-C 内存管理1.1. 简介1.2. 分区1.3. 引用计数1.3.1. autorelease1.3.2. alloc/retain/release/dealloc 实现1.4. 自动引用计数1.4.1. 使用方法1.4.2. 所有权修饰符1.4.3. __bridge 转换1.4.4. 属性1. Objective-C 内存管理 1.1. 简介 1.2. 分区 分区 特点 栈区（stack） 由编译器自动完成分配合释放，不需要程序员手动管理，主页存储了函数的参数和局部变量值等。 堆区（heap） 需要程序员手动开辟并管理内存。 BSS 段（全局区）（静态区）（未初始化常量区.bss） 程序运行过程内存的数据一直存在，程序结束后由系统释放 常量区（数据段）（已初始化常量区.data） 专门用于存放常量，程序结束后由系统释放 程序代码区（.text） 用于存放程序运行时的代码，代码会被编译成二进制，存进内存的程序代码区 1.3. 引用计数 引用计数式内存管理的思考方式： 自己生成的对象，自己所持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放 对象操作与 Objective-C 方法的对应： 对象操作 Objective-C 方法（NSObject） 生成并持有对象 alloc/new/copy/mutableCopy 等方法 持有对象 retain 方法 释放对象 release 方法 废弃对象 dealloc 方法 1.3.1. autorelease autorelease 提供使对象在超出指定的生存范围时，能够自动并正确地释放（调用 release 方法）。autorelease 不立即释放，注册到 autoreleasepool 中，在 pool 结束时自动调用release。 autorelease 的具体使用方法： 生成并持有 NSAutoreleasePool 对象 调用已分配对象的 autorelease 实例方法 废弃 NSAutoreleasePool 对象（对每个对象自动调用 release） NSAutoreleasePool 对象的生存周期相当于 C 语言变量的作用域。对于所有调用过 autorelease 实例方法的对象，在废弃 NSAutoreleasePool 对象时，都将调用 release 实例方法。源码如下： NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; id obj = [[NSObject alloc] init]; [obj autorelease]; [pool drain]; // 此时调用 release 在 Cocoa 框架中，相当于程序主循环的 NSRunLoop 或者在其他程序可运行的地方，对 NSAutoreleasePool 对象进行生成、持有和废弃处理。但是在大量产生 autorelease 的对象时，只要不废弃 NSAutoreleasePool 对象，生成的对象就不能释放，因此可能会发生内存不足的现象。例如大量读入图像并修改生成新的 UIImage 对象。为避免此情况，需要在适当的地方生成、持有或废弃 NSAutoreleasePool 对象。 在 Cocoa 框架中，有很多类方法用于返回 autorelease 的对象，比如：NSMutableArray 的 arrayWithCapacity 类方法。 id array = [NSMutableArray arrayWithCapacity:1]; // 等同于 id array = [[[NSMutableArray alloc] initWithCapacity:1] autorelease]; 注意事项： NSAutoreleasePool 类的autorelease 的实例方法已被该类重载，调用运行时会出错 1.3.2. alloc/retain/release/dealloc 实现 1.4. 自动引用计数 1.4.1. 使用方法 设置 ARC 有效的编译方法（Xcode 4.2 以上默认为 ARC）： 使用 clang（LLVM 编译器）3.0 或以上版本 指定编译器属性为 \"-fobjc-arc\" 1.4.2. 所有权修饰符 Objective-C 编程中为了处理对象，可将变量类型定义为 id 类型或各种对象类型。 对象类型就是指向 NSObject 这样的 Objective-C 类的指针，例如 \"NSObject *\" id 类型用于隐藏对象类型的类名部分，相当于 C 语言中常用的 \"void *\" ARC有效时，id 类型和对象类型必须附加所有权修饰符。所有权修饰符一共 4 种： __strong 修饰符 __weak 修饰符 __unsafe_unretained 修饰符 __autoreleasing 修饰符 strong 修饰符、weak 修饰符、autoreleasing 修饰符可以保证附有这些修饰符的自动变量初始化为 nil id __strong obj0; id __weak obj1; id __autoreleasing obj2; // 等同于 id __strong obj0 = nil; id __weak obj1 = nil; id __autoreleasing obj2 = nil; __strong 修饰符 __strong 修饰符是 id 类型和对象类型默认的所有权修饰符，在 id 和对象类型没有明确指定所有权修饰符时，默认为此修饰符。 { id obj = [[NSObject alloc] init]; // 等同于 id __strong obj = [[NSObject alloc] init]; } 附有 __strong 修饰符的变量在超出其作用域时，即该变量被废弃时，会释放其被赋予的对象。等同于 ARC 无效时，增加调用 release 方法，源码： { id __strong obj = [[NSObject alloc] init]; } // ARC 无效 { id obj = [[NSObject alloc] init]; [obj release]; } __strong修饰符表示对对象的强引用，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象也会随之释放。 自己生成并持有对象分析 { // 自己生成并持有对象 id __strong obj = [[NSObject alloc] init]; // 因为变量 obj 为强引用，所以自己持有对象 } // 因为变量 obj 超出其作用域，强引用失效 // 所以自动地释放自己持有的对象 // 对象的所有者不存在，因此废弃该对象 持有非自己生成的对象分析 { // 取得非自己生成并持有的对象 id __strong obj = [NSMutableArray array]; // 因为变量 obj 为强引用，所以自己持有对象 } // 因为变量 obj 超出其作用域，强引用失效 // 所以自动地释放自己持有的对象 总结 自己生成的对象自己持有和非自己生成的对象也能持有只需通过对待 strong 修饰符的变量赋值即可。通过废弃待 strong修饰符的变量（变量作用域结束或成员变量所属对象废弃）或者对变量赋值，都可做到不再需要自己持有的对象时释放。最后一项非自己持有的对象无法释放，由于不必再次键入 release ，所以根本不会执行。 __weak 修饰符 __unsafe_unretained 修饰符 __autoreleasing 修饰符 1.4.3. __bridge 转换 __bridge 转换：安全性与赋值和 __unsafe_unretained 修饰符相近，易因悬垂指针而崩溃（原变量 +0，新变量 +0） __bridge_retained 转换：转换赋值的变量也持有所赋值的对象（原变量 +0，新变量 +1） __bridge_transfer 转换：被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放（原变量 -1，新变量 +1） 1.4.4. 属性 属性声明的属性与所有权修饰符的对应关系如下： 属性声明的属性 所有权修饰符 assign __unsafe_unretained 修饰符 copy __strong 修饰符 retain __strong 修饰符 strong __strong 修饰符 unsafe_unretained __unsafe_unretained 修饰符 weak __weak 修饰符 以上各种属性赋值给指定的属性中就相当于赋值给附件各属性对应的所有权修饰符的变量中。只有 copy 不是简单的赋值，而是通过 NSCopying 接口的 copyWithZone: 方法复制赋值源所生成的对象。 注意事项： 在声明类成员变量时，如果同属性声明中的属性不一致则会引起编译错误 "},"ObjC/OC命名规范.html":{"url":"ObjC/OC命名规范.html","title":"命名规范","summary":"iOS Objective-C 命名规范","keywords":"","body":"1. Objective-C 命名规范1.1. 命名API1.2. Class and Protocol Names1.3. Header Files1.4. Naming Methods1.4.1. General Rules1.4.2. Accessor Methods1.4.3. Delegate Methods1.4.4. Collection Methods1.4.5. Method Arguments1.4.6. Private Methods1.5. Naming Functions1.6. Naming Properties and Data Types1.6.1. Declared Properties and Instance Variables1.6.2. Constants1.6.3. Constants created with const1.6.4. Other types of constants1.7. Notifications and Exceptions1.7.1. Notifications1.7.2. Exceptions1.8. 参考1. Objective-C 命名规范 项目命名规则 必须统一使用代表项目意义的名字。例如：Xcode中的项目文件统一命名。 可在target中 Class Prefix 统一配置类前缀。 公共文件 统一命名为 xx_Constant.h，CommonConfig.h，Macros.h。 对于文件的目录要按如下结构创建 （放在Project路径下的ProjectName文件夹下）： ⚠️ 所有文件夹必须是 实体文件夹 Global（全局文件，例如：xx_Constant.h，CommonConfig.h，Macros.h） ThirdLibs (第三方类库统一目录) Widget (自定义 UI组件) Utils（自定义Utils，Helper，类别工具） Resource （资源文件夹），其它资源文件放在单独的目录Resource中，并做细分。 图片资源全部放到 Assets.xcassets，另外为了方便图片资源文件管理，可以使用PDF矢量图片。 Class（模块文件），每个模块建立独立的文件夹进行管理。 Models (数据模型) Views（视图文件） Controllers（控制器）。 不要缩写事物的名称。将它们说清楚，即使它们很长： 尝试在整个项目中使用一致名称。 前缀是编程接口中名称的重要组成部分。它们区分软件的功能区域。通常，此软件打包在框架中，或者打包在紧密相关的框架中（例如，Foundation和Application Kit）。前缀可防止第三方开发人员定义的符号与Apple定义的符号之间以及Apple自己的框架中的符号之间发生冲突。前缀具有规定的格式。 它由两个或三个大写字母组成，不使用下划线或“子前缀”。 在命名类，协议，函数，常量和typedef结构时，请使用前缀。命名方法时请勿使用前缀；方法存在于由定义它们的类创建的名称空间中。另外，请勿使用前缀来命名结构的字段。 1.1. 命名API 对于由多个单词组成的名称，请勿将标点符号用作名称的一部分或用作分隔符（下划线，破折号等）；取而代之的是，将每个单词的第一个字母大写并一起运行这些单词（例如，runTheWordsTogether），这就是骆驼装箱。但是，请注意以下条件： 对于方法名称，请以小写字母开头，并大写嵌入单词的第一个字母。不要使用前缀。 对于函数和常量的名称，请使用与相关类相同的前缀，并大写嵌入单词的首字母。 避免使用下划线字符作为前缀，这意味着方法名称中是私有的（允许使用下划线字符作为实例变量名称的前缀）。苹果保留使用此约定。第三方使用可能会导致名称空间冲突；他们可能会不知不觉地使用自己的方法覆盖现有的私有方法，从而造成灾难性的后果。有关私有API遵循的约定的建议，请参见私有方法。 1.2. Class and Protocol Names 类的名称应包含一个名词，以清楚地指示该类（或该类的对象）表示或做什么。该名称应具有适当的前缀（请参阅前缀）。 Foundation和应用程序框架中充满了示例；一些是NSString，NSDate，NSScanner，NSApplication，UIApplication，NSButton和UIButton。协议应根据它们对行为的分组方式来命名： 大多数协议都会将与方法相关的方法归为一组，而这些方法并不与任何类特别相关。应当为此类协议命名，以免将协议与类混淆。常见的约定是使用... ing形式 一些协议将许多不相关的方法组合在一起（而不是创建几个单独的小型协议）。这些协议倾向于与作为该协议主要表达的类相关联。在这些情况下，约定是为协议赋予与类相同的名称。 此类协议的一个示例是NSObject协议。该协议对方法进行了分组，您可以使用这些方法来查询任何对象在类层次结构中的位置，使其调用特定的方法，以及增加或减少其引用计数。由于NSObject类提供了这些方法的主要表达，因此协议以该类命名。 1.3. Header Files 声明隔离的类或协议。如果某个类或协议不是组的一部分，则将其声明放在一个单独的文件中，该文件的名称与所声明的类或协议的名称相同。 声明相关的类和协议。对于一组相关的声明（类，类别和协议），请将声明放在带有主要类，类别或协议的名称的文件中。 包括框架头文件。每个框架都应该有一个以该框架命名的头文件，该头文件包括该框架的所有公共头文件。 1.4. Naming Methods 1.4.1. General Rules 名称以小写字母开头，并大写嵌入单词的第一个字母。不要使用前缀。 对于表示对象采取的操作的方法，请以动词开头名称：select、invoke等 如果该方法返回接收方的属性，请在该属性后命名该方法。除非间接返回一个或多个值，否则不需要使用“ get”。 使参数之前的单词描述参数。 当您创建比继承的方法更具体的方法时，请在现有方法的末尾添加新的关键字。 不要使用“和” 连接作为接收者属性的关键字。如果该方法描述了两个单独的操作，请使用“和”链接它们。 1.4.2. Accessor Methods 访问器方法是那些设置和返回对象属性值的方法。根据属性的表达方式，它们具有某些推荐的形式： 如果该属性表示为名称，则格式为： - (type)noun; - (void)setNoun:(type)aNoun; 如果该属性表示为形容词，则格式为： - (BOOL)isEditable; - (void)setEditable:(BOOL)flag; 如果该属性表示为形容词，则格式为： - (BOOL)showsAlpha; - (void)setShowsAlpha:(BOOL)flag; 不要通过分词把动词变成形容词，例如 acceptsGlyphInfo 和 glyphInfoAccepted 您可以使用情态动词（以“ can”，“ should”，“ will”等开头的动词）来阐明含义，但不要使用“ do”或“ does”。 仅将“ get”用于间接返回对象和值的方法。仅当需要返回多个项目时，才应将此表格用于方法。 1.4.3. Delegate Methods 委托方法（或委托方法）是对象在某些事件发生时在其委托中调用的方法（如果委托实现了委托方法）。它们具有独特的形式，同样适用于对象数据源中调用的方法： 通过标识发送消息的对象的类别来开始命名，类名省略前缀，首字母小写。 除非该方法只有一个参数，即发送方，否则在类名后加一个冒号（该参数是对委派对象的引用）。 例外情况是由于发布通知而调用的方法。在这种情况下，唯一的参数是通知对象。 对调用的方法使用“ did”或“ will”来通知委托人某事已发生或将要发生。 尽管可以将“ did”或“ will”用于调用以要求委托人代表另一个对象做某事的方法，但“ should”是优选的。 1.4.4. Collection Methods 对于管理对象集合（每个称为该集合的元素）的对象，约定应具有以下形式的方法： - (void)addElement:(elementType)obj; - (void)removeElement:(elementType)obj; - (NSArray *)elements; - (void)insertElement:(elementType)obj atIndex:(int)index; - (void)removeElementAtIndex:(int)index; 如果集合确实是无序的，则返回NSSet对象而不是NSArray对象。 1.4.5. Method Arguments 与方法一样，参数以小写字母开头，连续单词的首字母大写（例如，删除Object：（id）Object）。 名称中请勿使用“指针”或“ pointer”。让参数的类型而不是名称声明它是否是指针。 避免为参数使用一个字母和两个字母的名称。 避免只保存几个字母的缩写。 传统上，以下关键字和参数一起使用： ...action:(SEL)aSelector ...alignment:(int)mode ...atIndex:(int)index ...content:(NSRect)aRect ...doubleValue:(double)aDouble ...floatValue:(float)aFloat ...font:(NSFont *)fontObj ...frame:(NSRect)frameRect ...intValue:(int)anInt ...keyEquivalent:(NSString *)charCode ...length:(int)numBytes ...point:(NSPoint)aPoint ...stringValue:(NSString *)aString ...tag:(int)anInt ...target:(id)anObject ...title:(NSString *)aString 1.4.6. Private Methods 在大多数情况下，私有方法名称通常遵循与公共方法名称相同的规则。但是，通常的约定是为私有方法提供前缀，因此很容易将它们与公共方法区分开。即使采用此约定，给私有方法指定的名称也可能导致特殊类型的问题。当设计Cocoa框架类的子类时，您将无法知道您的私有方法是否无意中覆盖了同名的私有框架方法。 Cocoa框架中大多数私有方法的名称都有下划线前缀（例如_fooData），以将其标记为私有。基于这个事实，遵循两个建议。 如果您要继承大型Cocoa框架类（例如NSView或UIView），并且要绝对确保私有方法的名称与超类中的名称不同，则可以在私有方法中添加自己的前缀。前缀应尽可能唯一，也许是基于您公司或项目的前缀，形式为“ XX_”。因此，如果您的项目名为Byte Flogger，则前缀可能是BF_addObject： 尽管给私有方法名称加前缀的建议似乎与先前的主张称其方法存在于其类的命名空间中相矛盾，但此处的意图有所不同：防止意外覆盖超类私有方法。 1.5. Naming Functions Objective-C允许您通过函数和方法来表达行为。当基础对象总是单例或您正在处理明显的功能子系统时，您应该使用函数而不是类方法。 函数有一些一般的命名规则，你应该遵循： 函数名与方法名一样形成，但有几个例外： 它们以您用于类和常量的相同前缀开头。 前缀后的第一个字母大写。 大多数函数名以描述函数效果的动词开头： 查询属性的函数有另外一组命名规则： 如果函数返回其第一个参数的属性，请省略动词。 如果引用返回值，请使用“获取”。 const char *NSGetSizeAndAlignment（const char *typePtr，unsigned int *sizep，unsigned int *alignp） 1.6. Naming Properties and Data Types 本节描述了声明的属性，实例变量，常量，通知和异常的命名约定。 1.6.1. Declared Properties and Instance Variables 声明的属性有效地声明了属性的访问器方法，因此命名已声明属性的约定与命名访问器方法的约定大致相同（请参阅访问器方法）。但是，如果声明的属性的名称表示为形容词，则属性名称会省略“ is”前缀，但可以指定get访问器的常规名称。 @property (strong) NSString *title; @property (assign) BOOL showsAlpha; @property (assign, getter=isEditable) BOOL editable; 确保实例变量的名称简洁地描述了存储的属性。通常，您不应该直接访问实例变量。相反，您应该使用访问器方法（您可以直接在init和dealloc方法中访问实例变量）。为了说明这一点，请在实例变量名称前加上下划线（_），例如： @implementation MyClass { BOOL _showsTitle; } 如果使用声明的属性合成实例变量，请在@synthesize语句中指定实例变量的名称。 @implementation MyClass @synthesize showsTitle=_showsTitle; 避免显式声明公共实例变量。 开发人员应该关注对象的界面，而不要关注对象如何存储数据的细节。您可以通过使用声明的属性并合成相应的实例变量来避免显式声明实例变量。 如果需要声明实例变量，请使用@private或@protected明确声明它。 如果您希望您的类将被子类化，并且这些子类将需要直接访问数据，请使用@protected指令 如果实例变量将作为类实例的可访问属性，请确保为其编写访问器方法（如果可能，请使用声明的属性）。 1.6.2. Constants 常量的规则根据常量的创建方式而有所不同 Enumerated constants 对具有整数值的相关常数组使用枚举。 枚举常量和对其进行分组的typedef遵循函数的命名约定（请参阅命名函数）。以下示例来自NSMatrix.h： typedef enum _NSMatrixMode { NSRadioModeMatrix = 0, NSHighlightModeMatrix = 1, NSListModeMatrix = 2, NSTrackModeMatrix = 3 } NSMatrixMode; 您可以创建位运算的枚举，例如： enum { NSBorderlessWindowMask = 0, NSTitledWindowMask = 1 1.6.3. Constants created with const 使用const为浮点值创建常量。如果该常量与其他常量无关，则可以使用const创建一个整数常量。否则，请使用枚举。 const float NSLightGray; 1.6.4. Other types of constants 通常，请勿使用#define预处理程序命令创建常量。如上所述，对于整数常量，请使用枚举；对于浮点常量，请使用const限定符。 使用大写字母表示预处理器在确定是否将处理代码块时评估的符号。例如：#ifdef DEBUG 请注意，编译器定义的宏具有前后双下划线字符。例如：__MACH__ 为用于通知目的名称和字典键之类的字符串定义常量。通过使用字符串常量，可以确保编译器验证指定的正确值（即，它执行拼写检查）。 Cocoa框架提供了许多字符串常量示例，例如：APPKIT_EXTERN NSString *NSPrintCopies; 。实际的NSString值分配给实现文件中的常量。 （请注意，APPKIT_EXTERN宏对Objective-C的值为extern。） 常量命名 若常量作用域局限于某编译单元（实现文件）内，则在常量名前面添加字母 k，如 static const NSTimeInterval kAnimationDuration = 0.3; 。为什么会是 k 呢？这其实是历史原因，在匈牙利命名法中，k 的意思是 constants，用以表示常量前缀。 若常量作用域超出编译单元，在类外可见时，使用类名前缀，如 extern NSString *const EOCStringConstant;。 1.7. Notifications and Exceptions 通知和例外的名称遵循类似的规则。但是两者都有自己的推荐用法模式。 1.7.1. Notifications 如果类具有委托，则委托的大多数通知可能会通过定义的委托方法由委托接收。这些通知的名称应反映相应的委托方法。例如，每当应用程序 NSApplicationDidBecomeActiveNotification 时，全局 NSApplication 对象的委托都会自动注册以接收 applicationDidBecomeActive：消息。 通知由名称由以下方式组成的全局NSString对象标识： [Name of associated class] + [Did | Will] + [UniquePartOfName] + Notification 例如： NSApplicationDidBecomeActiveNotification NSWindowDidMiniaturizeNotification NSTextViewDidChangeSelectionNotification NSColorPanelColorDidChangeNotification 1.7.2. Exceptions 尽管您可以随意选择将异常（即NSException类和相关函数提供的机制）用于任何选择的目的，但是Cocoa保留了用于编程错误的异常，例如数组索引超出范围。可可不使用异常来处理常规的预期错误情况。对于这些情况，请使用返回的值，例如nil，NULL，NO或错误代码。有关更多详细信息，请参见《错误处理编程指南》。 异常由全局NSString对象标识，其名称以这种方式组成： [Prefix] + [UniquePartOfName] + Exception 名称的唯一部分应将组成词放在一起，并大写每个词的第一个字母。这里有些例子： NSColorListIOException NSColorListNotEditableException NSDraggingException NSFontUnavailableException NSIllegalSelectorException 1.8. 参考 https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingFunctions.html#//apple_ref/doc/uid/20001283-BAJGGCAD https://www.jianshu.com/p/06cc78e8b8b6 https://www.jianshu.com/p/f4bebecf4100 "},"ObjC/OC注释.html":{"url":"ObjC/OC注释.html","title":"注释","summary":"Objective-C 注释","keywords":"","body":"1. Objective-C 注释1.1. 参考1. Objective-C 注释 Xcode8提供了快速生成格式化注释的快捷键：option+command+/。如果方法有参数，会自动添加@param关键字，用于描述对应的参数。 Apple提供了官方的headDoc语法，但是很多都已经在Xcode中失效了，而且有些关键字也和appleDoc不兼容。下面几种列举出了在Xcode中仍然有效的一些关键字： /** 演示苹果headDoc的语法。这里可以写方法简介 @brief 方法的简介(appleDoc不支持此关键字) @discussion 方法的详细说明 @param 方法参数 @code //示例代码(这个在Xcode里常用，但是appleDoc不支持此关键字) UIView *view; @endcode @bug 存在的bug的说明 @note 需要注意的提示 @warning 警告 @since iOS7.0 @exception 方法会抛出的异常的说明 @attention 注意，从这里开始往下的关键字，appleDoc都不支持 @author 编写者 @copyright 版权 @date 日期 @invariant 不变量 @post 后置条件 @pre 前置条件 @remarks 备注 @todo todo text @version 版本 */ - (void)sampleMethod; 1.1. 参考 https://www.jianshu.com/p/91c603061943 "},"iOS/":{"url":"iOS/","title":"iOS","keywords":"","body":"1. Introduction1. Introduction "},"iOS/iOS-Tips.html":{"url":"iOS/iOS-Tips.html","title":"iOS Tips","summary":"iOS Tips","keywords":"","body":"1. iOS Tips1.1. 屏幕旋转1.2. Home Indicator1. iOS Tips 1.1. 屏幕旋转 supportedInterfaceOrientations not called in iPad Requires full screen 1.2. Home Indicator 隐藏 Home 键，设置 prefersHomeIndicatorAutoHidden 为 true。设置后页面不再显示 Home Indicator，但点击后仍会出现，且上拉一次就会返回主页面。一般用于视频播放等页面 优先 App 内手势，设置 preferredScreenEdgesDeferringSystemGestures 为 UIRectEdgeAll。设置后，点击无法触发Home Indicator，只有从底部往上拉才会触发，并且第二次才会触发返回界面的动作。 prefersHomeIndicatorAutoHidden 和 preferredScreenEdgesDeferringSystemGestures 不可一起使用，否则后者不生效 "},"iOS/内购.html":{"url":"iOS/内购.html","title":"In-App-Purchase","summary":"iOS 内购","keywords":"","body":"1. In-App-Purchase1.1. 内购类型1.2. 收据验证1.3. 交易流程图1. In-App-Purchase 1.1. 内购类型 消耗型项目 非消耗性项目 自动续期订阅 非自动续期订阅 消耗型项目 非消耗型项目 自动续期订阅 非自动续期订阅 可以Restore 否 是 是 否 有时间限制 否 否 是 是 1.2. 收据验证 On-device validation Server-side validation Validates authenticity of receipt Yes Yes Includes renewal transactions Yes Yes Includes additional user subscription information No Yes Handles renewals without client dependency No Yes Resistant to device clock change No Yes 1.3. 交易流程图 graph TB appStart(App启动)-->register[注册交易观察者] register--SKPaymentQueue.defaultQueue addTransactionObserver:-->getProducts(根据ID获取Products) subgraph apple giveProducts[App Store提供Products Info] appleHandlePay[Apple处理支付订单] appleHandleRestore[Apple处理恢复购买] end subgraph user uesrSelectProduct[用户选择Product] uesrSelectRestore[用户选择恢复购买] end getProducts--SKProductsRequest实例方法start-->giveProducts giveProducts--SKProductsRequestDelegate-->appStoreUI[展示商店页面] giveProducts--SKProductsRequestDelegate-->invaildID[不合法ProductID] appStoreUI-->uesrSelectProduct uesrSelectProduct-->makePayReq[发送支付请求] makePayReq--SKPaymentQueue.defaultQueue addPayment-->appleHandlePay appleHandlePay--调用队列观察者的SKPaymentTransactionObserver中 paymentQueue:updatedTransactions:-->appleHandlePayRes[处理支付订单结果] appleHandlePayRes--Failed-->payFail[购买失败] appleHandlePayRes--Purchased-->payPurchased[已购买] appleHandlePayRes--Restored-->payRestored[恢复购买] appleHandlePayRes--Deferred-->payDeferred[购买延迟] appleHandlePayRes-- Purchasing-->payPurchasing[购买中] appStoreUI-->uesrSelectRestore uesrSelectRestore--SKPaymentQueue.defaultQueue restoreCompletedTransactions-->appleHandleRestore appleHandleRestore--调用队列观察者的SKPaymentTransactionObserver中 paymentQueue:updatedTransactions:和 paymentQueueRestoreCompletedTransactionsFinished: 或 paymentQueue:restoreCompletedTransactionsFailedWithError:-->appleHandlePayRes[处理恢复购买结果] payPurchased--SKPaymentTransaction-->paySuccessed[购买完成] payRestored--SKPaymentTransaction的originalTransaction获取到商品id支付凭证等信息-->paySuccessed[购买完成] paySuccessed--NSBundle mainBundle appStoreReceiptURL-->getReceipt[获取收据验证交易] getReceipt--本地验证-->AppVerifyReceipV[App验证收据] getReceipt--服务端验证-->ServerVerifyReceipV[服务端验证收据] AppVerifyReceipV-->unlock[解锁内容] ServerVerifyReceipV-->unlock[解锁内容] unlock--SKPaymentQueue.defaultQueue finishTransaction-->finish[完成交易] payFail--SKPaymentQueue.defaultQueue finishTransaction-->finish[完成交易] finish--SKPaymentQueue.defaultQueue removeTransactionObserver:-->appEnd(App停止) "},"iOS/后台下载.html":{"url":"iOS/后台下载.html","title":"后台下载","summary":"iOS 后台下载","keywords":"","body":"1. iOS 后台下载1.1. 官方指引1.1.1. 创建后台下载任务1.1.2. Access the File, or Move It to a Permanent Location1.1.3. Recreate the Session If the App Was Terminated1.1.4. Comply with Background Transfer Limitations1.1.5. Use Background Sessions Efficiently1.1.6. DownloadTask 断点续传1.1.7. Download Delegate Behavior1.1.8. 苹果现存 Bug1. iOS 后台下载 1.1. 官方指引 https://developer.apple.com/documentation/foundation/url_loading_system/downloading_files_in_the_background?language=objc# 1.1.1. 创建后台下载任务 创建一个会话配置对象，允许在后台执行 HTTP 和 HTTPS 上传或下载： class func background(withIdentifier identifier: String) -> URLSessionConfiguration 使用此方法初始化适合在应用程序在后台运行时传输数据文件的配置对象。使用此对象配置的会话将传输控制权移交给系统，系统在单独的进程中处理传输。在 iOS 中，即使应用程序本身暂停或终止，此配置也可以继续传输。 如果 iOS 应用程序被系统终止并重新启动，该应用程序可以使用相同的标识符来创建新的配置对象和会话，并检索终止时正在进行的传输的状态。此行为仅适用于系统正常终止应用程序。如果用户从多任务屏幕终止应用程序，系统将取消会话的所有后台传输。此外，系统不会自动重新启动用户强制退出的应用程序。用户必须明确地重新启动应用程序才能重新开始传输。 您可以使用 isDiscretionary 属性配置后台会话以根据系统的判断安排传输以获得最佳性能。传输大量数据时，建议您将此属性的值设置为 true。有关使用后台配置的示例，请参阅在后台下载文件。 1.1.2. Access the File, or Move It to a Permanent Location 一旦您恢复的应用程序调用完成处理程序，下载任务完成其工作并调用委托的 urlSession(_:downloadTask:didFinishDownloadingTo:) 方法。此时，文件已完全下载，并且在您的委托方法返回之前可用。如果您只需要阅读一次，您可以立即在其临时位置访问该文件。如果要保留文件，请将其移动到像 Documents 目录这样的永久位置，如从网站下载文件中所述。 1.1.3. Recreate the Session If the App Was Terminated 如果系统在暂停时终止应用程序，系统会在后台重新启动应用程序。作为启动时间设置的一部分，使用与以前相同的会话标识符重新创建后台会话，以允许系统将后台下载任务与您的会话重新关联。您这样做是为了让您的后台会话准备就绪，无论应用程序是由用户启动还是由系统启动。应用程序重新启动后，一系列事件与应用程序已暂停和恢复相同，如前面处理应用程序暂停中所述。 注意：如果在应用程序处于后台时启动传输，则会话配置的 isDiscretionary 属性被视为 true。 1.1.4. Comply with Background Transfer Limitations 对于后台会话，实际传输由与您的应用程序进程分开的进程执行。由于重新启动应用程序的进程相当昂贵，因此一些功能不可用，从而导致以下限制： 会话必须为事件传递提供委托。对于上传和下载，委托的行为与进程内传输相同 仅支持 HTTP 和 HTTPS 协议，不支持自定义协议 始终遵循重定向。结果，即使你已经实现了 urlSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)，它也不会被调用 仅支持从文件上传任务，应用退出后从数据实例或流上传失败 1.1.5. Use Background Sessions Efficiently 当系统恢复或重新启动您的应用程序时，它会使用速率限制器来防止滥用后台下载。当您的应用在后台启动新的下载任务时，该任务在延迟到期之前不会开始。每次系统恢复或重新启动您的应用程序时，延迟都会增加。 因此，如果您的应用程序开始单个后台下载，下载完成后恢复，然后开始新的下载，这将大大增加延迟。相反，使用少量后台会话（理想情况下只有一个）并使用这些会话一次启动许多下载任务。这允许系统一次执行多个下载，并在完成后恢复您的应用程序。 但请记住，每个任务都有自己的开销。如果您发现需要启动数千个下载任务，请更改您的设计以执行更少、更大的传输。 注意：每当用户将您的应用程序置于前台时，延迟都会重置为 0。如果延迟时间过去而系统没有恢复或重新启动您的应用程序，它也会重置。 1.1.6. DownloadTask 断点续传 A download can be resumed only if the following conditions are met: The resource has not changed since you first requested it The task is an HTTP or HTTPS GET request The server provides either the ETag or Last-Modified header (or both) in its response The server supports byte-range requests The temporary file hasn’t been deleted by the system in response to disk space pressure 1.1.7. Download Delegate Behavior When you use a download task, your delegate receives several callbacks unique to download scenarios. During download, the session periodically calls the delegate’s urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:) method with status information. Upon successful completion, the session calls the delegate’s urlSession(_:downloadTask:didFinishDownloadingTo:) method or completion handler. In that method, you must either open the file for reading or move it to a permanent location in your app’s sandbox container directory. Upon unsuccessful completion, the session calls the delegate’s urlSession(_:task:didCompleteWithError:) method or completion handler. The only errors your delegate receives through the error parameter are client-side errors, such as being unable to resolve the hostname or connect to the host. To check for server-side errors, inspect the response property of the task parameter received by this callback. 1.1.8. 苹果现存 Bug https://developer.apple.com/forums/thread/89574 https://developer.apple.com/forums/thread/73426 "},"macOS/":{"url":"macOS/","title":"macOS","keywords":"","body":"1. Introduction1. Introduction "},"macOS/App-Sandbox.html":{"url":"macOS/App-Sandbox.html","title":"App Sandbox","summary":"App Sandbox 沙盒机制","keywords":"","body":"1. macOS App Sandbox 沙盒机制1. macOS App Sandbox 沙盒机制 "},"macOS/AppKit.html":{"url":"macOS/AppKit.html","title":"AppKit","summary":"macOS Appkit","keywords":"","body":"1.1. NSWindow1.2. NSViewController1.3. NSView1.4. NSCollectionView1.1. NSWindow 1.2. NSViewController 在 macOS 10.10 及更高版本中，NSViewController 使用初始化方法 [[MyViewController alloc] init] 时，调用 loadView 将加载与 NSViewController 同名的 Nib 文件，将 Nib 文件实例化视图连接到视图控制器的视图属性。如果不存在 Nib 文件，会触发运行时崩溃： -[NSNib _initWithNibNamed:bundle:options:] could not load the nibName: NSViewController in bundle (null). 解决办法：重写 loadView 方法 - (void)loadView { } 1.3. NSView 在 macOS 10.10 及更高版本中，NSView 使用初始化方法时，调用 loadView 将加载与 NSView 同名的 Nib 文件，将 Nib 文件实例化视图连接到视图控制器的视图属性。如果不存在 Nib 文件，会触发运行时崩溃： -[NSNib _initWithNibNamed:bundle:options:] could not load the nibName: NSView in bundle (null). 解决办法：重写 loadView 方法 - (void)loadView { } 1.4. NSCollectionView 在低版本系统下，NSCollectionView 必须嵌套在 NSScrollView 中，否则 dataSource 中的 func collectionView(_ collectionView: NSCollectionView, itemForRepresentedObjectAt indexPath: IndexPath) -> NSCollectionViewItem 回调不会执行。 实例代码: lazy var flowLayout: NSCollectionViewFlowLayout = { let layout = NSCollectionViewFlowLayout() layout.scrollDirection = .vertical layout.itemSize = CGSize(width: (view.frame.width - 80) / 2, height: 40) layout.minimumLineSpacing = 20 layout.minimumInteritemSpacing = 20 layout.headerReferenceSize = NSZeroSize layout.footerReferenceSize = NSZeroSize layout.sectionInset = NSEdgeInsets(top: 20, left: 20, bottom: 20, right: 20) return layout }() let homeCollectionViewReuseIdentifier = NSUserInterfaceItemIdentifier(rawValue: \"HomeViewItem\") lazy var collectionView: NSCollectionView = { let collectionView = NSCollectionView() collectionView.collectionViewLayout = self.flowLayout collectionView.register(HomeViewItem.self, forItemWithIdentifier: homeCollectionViewReuseIdentifier) collectionView.dataSource = self collectionView.delegate = self return collectionView }() lazy var scrollView: NSScrollView = { let scrollView = NSScrollView() // 必须将 NSCollectionView 嵌入到 NSScrollView，否则低版本系统无法正常显示 scrollView.documentView = collectionView scrollView.autohidesScrollers = true return scrollView }() "},"Mac/":{"url":"Mac/","title":"Mac","keywords":"","body":"1. Introduction1. Introduction "},"Mac/Mac终端zsh忽略大小写.html":{"url":"Mac/Mac终端zsh忽略大小写.html","title":"Mac终端zsh忽略大小写","summary":"Mac终端zsh忽略大小写","keywords":"","body":"Mac 终端默认是大小写不敏感的，cd desktop 其实也能切到桌面，但是无法通过tab补全。 如果你已经使用了zsh，那么一般情况下，修改.inputrc 并没有效果。 在.zshrc 里添加下面两个命令并重启后可以忽略大小写。 # Ignore lower upper autoload -Uz compinit && compinit -u zstyle ':completion:*' matcher-list 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' "},"Mac/Mac键盘快捷键.html":{"url":"Mac/Mac键盘快捷键.html","title":"Mac键盘快捷键","summary":"Xcode使用总结","keywords":"","body":"1.1.1. Mac OS 外接键盘映射1.1.2. 键盘按键使用符合1.1.3. 剪切、拷贝、粘贴和其他常用快捷键1.1.4. 睡眠、退出登录和关机快捷键1.1.5. 访达和系统快捷键1.1.6. 文稿快捷键1.1.7. Mac 的启动组合键1.1.8. Mac 上的“聚焦”键盘快捷键1.1.9. Mac 上 Safari 浏览器中的键盘快捷键和手势1.2. Xcode1.2.1. Xcode常用快捷键1.2.2. Xcode 自定义组合快捷键1.1.1. Mac OS 外接键盘映射 修饰键 符号 外接键盘 Command ![Command 符号](/assets/9808e0a4c5ca7d8f3661af19ca54058e.png Win Shift Shift Option Alt Control Ctrl 1.1.2. 键盘按键使用符合 修饰键 符号 Command Shift Option Control Return Delete 向前删除键 上箭头键 下箭头键 左箭头键 右箭头键 Page Up Page Down Top (Home) End 右制表符 左制表符 Escape (Esc) 1.1.3. 剪切、拷贝、粘贴和其他常用快捷键 Command-X：剪切所选项并拷贝到剪贴板。 Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。 Command-V：将剪贴板的内容粘贴到当前文稿或 App 中。这同样适用于“访达”中的文件。 Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些 App 中，您可以撤销和重做多个命令。 Command-A：全选各项。 Command-F：查找文稿中的项目或打开“查找”窗口。 Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Command-H：隐藏最前面的 App 的窗口。要查看最前面的 App 但隐藏所有其他 App，请按 Option-Command-H。 Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的 App 的所有窗口，请按 Option-Command-M。 Command-O：打开所选项，或打开一个对话框以选择要打开的文件。 Command-P：打印当前文稿。 Command-S：存储当前文稿。 Command-T：打开新标签页。 Command-W：关闭最前面的窗口。要关闭 App 的所有窗口，请按下 Option-Command-W。 Option-Command-Esc：强制退出 App。 Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。） Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。 Control-Command-F：全屏使用 App（如果 App 支持）。 空格键：使用快速查看来预览所选项。 Command-Tab：在打开的 App 中切换到下一个最近使用的 App。 Shift-Command-5：在 macOS Mojave 或更高版本中，拍摄截屏或录制屏幕。也可以使用 Shift-Command-3 或 Shift-Command-4 来拍摄截屏。进一步了解截屏。 Shift-Command-N：在“访达”中创建一个新文件夹。 Command-逗号 (,)：打开最前面的 App 的偏好设置。 1.1.4. 睡眠、退出登录和关机快捷键 在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样有助于避免无意中启用快捷键。 电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。*继续按住则会强制您的 Mac 关机。 Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。 Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。 Control–电源按钮* 或 Control–介质推出键 ：显示一个对话框，询问您是要重新启动、睡眠还是关机。 Control–Command–电源按钮*：强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。 Control–Command–Media Eject（Control–Command–介质推出键）：退出所有 App，然后重新启动您的Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control–Option–Command–电源按钮* 或 Control–Option–Command–介质推出键 ：退出所有 App，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control-Command-Q：立即锁定屏幕。 Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 1.1.5. 访达和系统快捷键 Command-D：复制所选文件。 Command-E：推出所选磁盘或宗卷。 Command-F：在“访达”窗口中开始“聚焦”搜索。 Command-I：显示所选文件的“显示简介”窗口。 Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些 App（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。 Shift-Command-C：打开“电脑”窗口。 Shift-Command-D：打开“桌面”文件夹。 Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。 Shift-Command-G：打开“前往文件夹”窗口。 Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。 Shift-Command-I：打开 iCloud 云盘。 Shift-Command-K：打开“网络”窗口。 Option-Command-L：打开“下载”文件夹。 Shift-Command-N：新建文件夹。 Shift-Command-O：打开“文稿”文件夹。 Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。 Shift-Command-R：打开“隔空投送”窗口。 Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。 Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本） Shift-Command-U：打开“实用工具”文件夹。 Option-Command-D：显示或隐藏“程序坞”。 Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。 Option-Command-P：隐藏或显示“访达”窗口中的路径栏。 Option-Command-S：隐藏或显示“访达”窗口中的边栏。 Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。 Command-J：显示“显示”选项。 Command-K：打开“连接服务器”窗口。 Command-L：为所选项制作替身。 Command-N：打开一个新的“访达”窗口。 Option-Command-N：新建智能文件夹。 Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。 Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。 Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。 Command-Y：使用“快速查看”预览所选文件。 Option-Command-Y：显示所选文件的快速查看幻灯片显示。 Command-1：以图标方式显示“访达”窗口中的项目。 Command-2：以列表方式显示“访达”窗口中的项目。 Command-3：以分栏方式显示“访达”窗口中的项目。 Command-4：以画廊方式显示“访达”窗口中的项目。 Command–左中括号 ([)：前往上一文件夹。 Command–右中括号 (])：前往下一个文件夹。 Command–上箭头：打开包含当前文件夹的文件夹。 Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。 Command–下箭头：打开所选项。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。 左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。 Command-Delete：将所选项移到废纸篓。 Shift-Command-Delete：清倒废纸篓。 Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。 Command–调高亮度：打开或关闭目标显示器模式。 Command–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。 Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。 Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。 Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。 Option–“调度中心”：打开“调度中心”偏好设置。 Command–调度中心：显示桌面。 Control–下箭头：显示最前面的 App 的所有窗口。 Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。 Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。 Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。 Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。 连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。 连按 Command 键：在单独的标签页或窗口中打开文件夹。 按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。 拖移时按住 Option-Command：为拖移的项目制作替身。拖移项目时指针会随之变化。 按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。这个快捷键仅在列表视图中有效。 按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。 了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 1.1.6. 文稿快捷键 这些快捷键的行为可能因您使用的 App 而异。 Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。 Command-K：添加网页链接。 Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。 Command-T：显示或隐藏“字体”窗口。 Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。 Control-Command-D：显示或隐藏所选字词的定义。 Shift-Command–冒号 (:)：显示“拼写和语法”窗口。 Command–分号 (;)：查找文稿中拼写错误的字词。 Option-Delete：删除插入点左边的字词。 Control-H：删除插入点左边的字符。也可以使用 Delete 键。 Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。 Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。 Control-K：删除插入点与行或段落末尾处之间的文本。 Fn–上箭头：Page Up：向上滚动一页。 Fn–下箭头：Page Down：向下滚动一页。 Fn–左箭头：Home：滚动到文稿开头。 Fn–右箭头：End：滚动到文稿末尾。 Command–上箭头：将插入点移至文稿开头。 Command–下箭头：将插入点移至文稿末尾。 Command–左箭头：将插入点移至当前行的行首。 Command–右箭头：将插入点移至当前行的行尾。 Option–左箭头：将插入点移至上一字词的词首。 Option–右箭头：将插入点移至下一字词的词尾。 Shift-Command–上箭头：选中插入点与文稿开头之间的文本。 Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。 Shift-Command–左箭头：选中插入点与当前行行首之间的文本。 Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。 Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。 Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。 Shift–左箭头：将文本选择范围向左扩展一个字符。 Shift–右箭头：将文本选择范围向右扩展一个字符。 Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。 Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。 Control–A：移至行或段落的开头。 Control–E：移至行或段落的末尾。 Control–F：向前移动一个字符。 Control–B：向后移动一个字符。 Control–L：将光标或所选内容置于可见区域中央。 Control–P：上移一行。 Control–N：下移一行。 Control–O：在插入点后新插入一行。 Control–T：将插入点后面的字符与插入点前面的字符交换。 Command–左花括号 ({)：左对齐。 Command–右花括号 (})：右对齐。 Shift-Command–竖线 (|)：居中对齐。 Option-Command-F：前往搜索栏。 Option-Command-T：显示或隐藏 App 中的工具栏。 Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。 Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。 Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。 Option-Command-I：显示或隐藏检查器窗口。 Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。 Shift-Command-S：显示“存储为”对话框或复制当前文稿。 Shift-Command-减号 (-)：缩小所选项。 Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。 Shift-Command–问号 (?)：打开“帮助”菜单。 1.1.7. Mac 的启动组合键 了解可通过在启动时按住一个或多个按键来访问的 Mac 功能和工具。 要使用这些组合键中的任何一个，请在按下电源按钮以开启 Mac 后或在 Mac 开始重新启动后，立即按住相应按键。请一直按住，直至电脑出现对应的行为。 Command (⌘)-R：从内建的 macOS 恢复系统启动。或者，您也可以使用 Option-Command-R 或 Shift-Option-Command-R 以通过互联网从 macOS 恢复功能启动。macOS 恢复功能可以安装不同版本的 macOS，具体取决于您在电脑启动时使用的组合键。如果您的 Mac 使用了固件密码，系统将提示您输入这个密码。 Option (⌥) 或 Alt：启动进入“启动管理器”，您可以从中选取其他可用的启动磁盘或宗卷。如果您的 Mac 使用了固件密码，系统将提示您输入这个密码。 Option-Command-P-R：重置 NVRAM 或 PRAM。如果您的 Mac 使用了固件密码，电脑会忽略这个组合键或从 macOS 恢复功能启动。 Shift (⇧)：以安全模式启动。如果使用了固件密码，这个组合键将被停用。 D：启动进入“Apple 诊断”实用工具。或者，您也可以使用 Option-D 通过互联网启动进入这个实用工具。如果使用了固件密码，这个组合键将被停用。 N：从 NetBoot 服务器启动，前提是您的 Mac 支持网络启动宗卷。要使用服务器上默认的引导映像，请按住 Option-N。如果使用了固件密码，这个组合键将被停用。 Command-S：以单用户模式启动。如果运行的是 macOS Mojave 或更高版本，或者使用了固件密码，这个组合键将被停用。 T：以目标磁盘模式启动。如果使用了固件密码，这个组合键将被停用。 Command-V：以详细模式启动。如果使用了固件密码，这个组合键将被停用。 推出键 (⏏)、F12、鼠标按钮或触控板按钮：推出可移动介质，例如光盘。如果使用了固件密码，这个组合键将被停用。 1.1.8. Mac 上的“聚焦”键盘快捷键 在 Mac 上使用键盘快捷键通过“聚焦”快速搜索。 操作 快捷键 打开“聚焦”以启动搜索 Command-空格键 使用建议的结果完成搜索 右箭头键 移到下一个搜索结果 下箭头键 移到上一个搜索结果 上箭头键 移到下一个类别中的第一个搜索结果 Command-下箭头 移到上一个类别中的第一个搜索结果 Command-上箭头 显示 Mac 上的搜索结果（如文件）路径 Command 放大图像预览 Control 键（然后在触控板上移动双指以在预览中移动图像） 打开所选结果 Return 键 在 App 或“访达”中查看文件 Command-R 或 Command-连按 打开搜索结果已选定的“访达”窗口 Option-Command-空格键 1.1.9. Mac 上 Safari 浏览器中的键盘快捷键和手势 除 Safari 浏览器菜单中显示的快捷键外，您还可以使用以下快捷键。 网页 操作 快捷键或手势 向上、向下、向左或向右滚动 按下箭头键。 大幅度滚动 按下箭头键时按住 Option 键。 向下滚动屏幕 Page Down 键空格键 向上滚动屏幕 Page Up 键Shift-空格键 滚动到页面左上角或左下角 Command–上箭头键或 Home 键Command–下箭头键或 End 键 高亮显示网页上的下一项 Tab 将高亮显示下一文本栏或弹出式菜单。如果在“系统偏好设置”的“键盘”面板的“快捷键”面板中选择了“所有控制”，Tab 还将高亮显示按钮和其他控制。按下 Option-Tab 会高亮显示按下 Tab 键所高亮显示的项目，以及所有其他可点按项目。若要交换 Tab 和 Option-Tab 的行为，请在 Safari 浏览器偏好设置的“高级”面板中打开“按下 Tab 键以高亮显示网页上的每一项”。 显示所有标签页 Shift-Command-\\ 在新标签页中打开页面 按住 Command 键点按链接按住 Command 键点按书签在智能搜索栏中键入后，按下 Command-Return。 在新标签页中打开页面，并使该标签页成为活跃标签页 按住 Shift-Command 点按链接按住 Shift-Command 点按书签在智能搜索栏中键入后，按下 Shift-Command-Return。 使下一标签页成为活跃标签页 Control-Tab 或 Shift-Command-] 使上一标签页成为活跃标签页 Control-Shift-Tab 或 Shift-Command -[ 选择前 9 个标签页中的一个 Command-1 到 Command-9 关闭全部标签页，只保留其中一个 按住 Option 键点按您要保持打开的标签页上的“关闭”按钮 重新打开上次关闭的标签页或窗口 Shift-Command-T 按名称查看最近访问页面的列表 按住“后退” 或“前进” 按钮，直到列表出现 按网址 (URL) 查看最近访问页面的列表 按下 Option 键，并按住“后退”或“前进”按钮，直到列表出现 前往主页 Command-Home 键 在智能搜索栏中键入时，恢复当前网页地址 Esc 键 关闭阅读器 Esc 键 退出全屏幕视图 Esc 键 下载链接文件 按住 Option 键点按文件的链接 打开下载的文件 连按下载列表中的文件 缩放网站内容 按下 Command-加号 (+) 或 Command-减号 (–) 缩放网站文本 选取“显示”>“使文本变大”或“显示”>“使文本变小”时，按下 Option 键。 阅读列表 操作 快捷键或手势 显示或隐藏阅读列表边栏 Control-Command-2 添加当前页面 Shift-Command-D 添加链接页面 按住 Shift 键点按页面的链接 移除页面 按住 Control 键点按边栏中的页面摘要，然后选取“移除项目”。您也可以在页面摘要上向左轻扫，然后点按“移除”。或者，一直向左轻扫直至页面摘要消失。 书签 操作 快捷键或手势 将书签添加到“个人收藏”栏 点按智能搜索栏以显示页面的完整地址及其图标，然后将图标拖移到“个人收藏”栏 打开“个人收藏”栏中某个文件夹内的所有书签 按住 Command 键点按“个人收藏”栏中的文件夹 在“个人收藏”栏上移动书签 左右拖移书签 从“个人收藏”栏移除书签 将书签拖移到个人收藏栏外 书签边栏和书签视图 操作 快捷键或手势 显示或隐藏书签边栏 Control-Command-1 选择边栏中的书签和文件夹 按住 Command 键点按每个书签和文件夹按住 Shift 键点按以扩展选择 选择下一个书签或文件夹 上箭头键或下箭头键 打开所选书签 空格键 打开所选文件夹 空格键或右箭头键 关闭所选文件夹 空格键或左箭头键 更改书签的名称或地址 选择书签，然后按下 Return 键您还可以用力点按书签 取消编辑边栏中的书签名称 Esc 键 完成编辑书签名称 Return 键 创建包含书签视图中的所选书签和文件夹的文件夹 按下 Option 键点按右上角附近的“新建文件夹”按钮 删除书签 按住 Control 键点按书签，然后选取“删除” 1.2. Xcode 1.2.1. Xcode常用快捷键 代码编辑 代码编辑 Mac 代码左缩进 Command + [ 代码右缩进 Command + ] 代码格式化 Control + I 光标移到前一行（previous） Control + P 光标移到后一行（next） Control + N 光标移到行首 Control + A 光标移到行尾（end） Control + E 调换光标两边的字符，并移动光标到两个字符后（transpose） Control + T 删除光标右侧字符 Control + D / Delete 删除本行光标右侧所有字符（kill） Control + K 快速打开文件 Command + Shift + O Clean Build Folder Command + Shift + K 查看 查看 Mac 查看当前文件的方法列表 Control + 6 查看当前文件夹的文件列表 Control + 5 查看最近查看历史 Control + 2 导航 导航 Mac 查看当前文件的上一个部分（头文件或源文件） Control + Command + ↑ 查看当前文件的下一个部分（头文件或源文件） Control + Command + ↓ 前进 Control + Command + → 后退 Control + Command + ← 1.2.2. Xcode 自定义组合快捷键 修改 Xcode 里快捷键的配置文件 (plist) 权限，打开终端输入如下两条命令: sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist sudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/ 打开 plist 文件 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist 复制一行快捷键 在Insertions and Indentations下添加 key ：Duplicate Current Line，值为： selectLine:, copy:, moveToEndOfLine:, moveToBeginningOfLine:, paste:, moveBackward: 绑定快捷键 Command + D 删除整行快捷键 在 Deletions 下添加一个 key ：Delete Current Line 值为： deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward: "},"Mac/Mac开源软件.html":{"url":"Mac/Mac开源软件.html","title":"Mac开源软件","summary":"Xcode使用总结","keywords":"","body":"1.1. Boop 编程开发辅助神器（Swift）1.2. Hidden Bar 菜单栏图标隐藏工具（Swift）1.3. Dozer 隐藏Mac菜单栏图标（Swift）1.4. Mos 鼠标平滑滚动反转（Swift）1.5. IINA 视频播放器（Swift）1.6. FSNotes 程序员笔记应用（Swift）1.7. AltTab 窗口快速切换利器（Swift）1.8. Rectangle 开源Mac窗口管理应用（Swift）1.9. uPic Mac图床客户端（Swift）1.10. OpenInTerminal 在当前目录打开终端（Swift）1.11. MonitorControl 菜单栏显示器音量亮度调节（Swift）1.12. NetNewsWire RSS新闻订阅客户端（Swift）1.13. Karabiner-Elements 键盘键位修改神器（Swift）1.14. CotEditor 开源免费的文本编辑器（Swift）1.15. Thor 通过快捷键快速打开应用（Swift）1.16. LyricsX 菜单栏及桌面歌词显示（Swift）1.17. Pock 在TouchBar中显示Dock栏图标（Swift）1.18. Stats 菜单栏系统监视器（Swift）1.19. Gifski 从视频中提取gif动图（Swift）1.20. Retroactive 解锁MacOS软件系统限制（Swift）1.21. PicGo 跨平台图床软件1.22. Stretchly 休息提醒工具1.23. Terminus 支持SSH的mac终端模拟器1.24. Electerm 终端模拟器/ssh/sftp客户端1.25. 洛雪音乐 全网音乐播放下载工具1.26. KeeWeb 跨平台密码管理器1.27. Buttercup 跨平台密码管理器1.28. Listen 付费VIP音乐免费听1.29. Mark Text Markdown编辑器1.30. Motrix 全能的下载工具1.31. NTFSTool NTFS硬盘读写工具1.32. SwitchHosts! mac hosts修改工具1.33. magnetW 磁力聚合搜索工具1.34. draw.io 流程图绘制应用1.1. Boop 编程开发辅助神器（Swift） Boop 是一款编程开发辅助应用。通过 command + b 键即可快速帮助您进行 JSON 解析、URL编码解码、Base64解码编码、计算MD5哈希值、JWT解码、XML格式化、JSON转CSV、css格式化、Javascript压缩格式化、SQL格式化等等功能。需要注意的是通过 command + b 键调用出功能列表后，要使用上下箭头选择，回车键确认。 项目地址：https://github.com/IvanMathy/Boop 1.2. Hidden Bar 菜单栏图标隐藏工具（Swift） Hidden Bar 是一款 macOS 菜单栏图标隐藏工具。使用方法：按住 ⌘ Command 键，拖动想要折叠的图标移到「｜」图标左侧就可以了，点击「>」箭头图标就可以直接隐藏菜单栏图标。不过要注意一个逻辑问题，「>」图标不能放置在「｜」图标左侧。 项目地址：https://github.com/dwarvesf/hidden 1.3. Dozer 隐藏Mac菜单栏图标（Swift） Dozer 是一款隐藏macOS菜单栏图标的应用，不同于 Bartender 和 Vanilla，Dozer 是免费、开源的。Dozer 操作方法也很简单，Dozer运行后在菜单栏会出现一个「‧」，点击它，然后会出现另外一个「‧」，按住 command 键拖曳「‧」调整到适当位置，然后点击一下「‧」就会隐藏第一个「‧」左边的图标，重新显示也只需要点击「‧」即可。 项目地址：https://github.com/Mortennn/Dozer 1.4. Mos 鼠标平滑滚动反转（Swift） Mos 是mac上一款针对非原装鼠标不能平滑滚动的鼠标平滑滚动工具，Mos最主要的功能就是让你的鼠标滚动效果达到和妙控鼠标（Magic Mouse）/ 妙控板（Magic Trackpad）一样的如丝般顺滑的滚动体验。对于没有买妙控鼠标（Magic Mouse）的人来说这是一款神器。 项目地址：https://github.com/Caldis/Mos 1.5. IINA 视频播放器（Swift） IINA 是一款采用现代设计和流线型功能的在线mac视频播放器，可以观看视频，管理播放列表，处理媒体内容或为电影加载字幕提等等。IINA mac可以加载本地文件或提供视频URL，IINA mac可以使用所有流行的媒体格式。而且您可以快速更改界面主题，调整默认行为和用户界面，决定是否要自动加载字幕，配置新的键绑定等。 项目地址：https://github.com/iina/iina 1.6. FSNotes 程序员笔记应用（Swift） FSNotes 是一款本地的Mac笔记应用，支持markdown、rtf、txt格式，它将数据存储在本地文件系统中而非云端，安全，稳定。 项目地址：https://github.com/glushchenko/fsnotes 1.7. AltTab 窗口快速切换利器（Swift） AltTab 是一款适用于 macOS 的窗口切换工具，将 Windows 的 alt-tab 窗口切换功能带到了 macOS 中。用法： 按下 ⌥ option + ⇥ tab 显示窗口缩略图。 继续按 ⌥ option + ⇥ tab 选择下一个窗口。 按住 ⌥ option + ⇧ shift + ⇥ tab 选择上一个缩略图。 松开 ⌥ option 以将焦点切换到窗口。 项目地址：https://github.com/lwouis/alt-tab-macos 1.8. Rectangle 开源Mac窗口管理应用（Swift） Rectangle 是一款开源免费的 Mac 窗口管理工具。Rectangle 可以让用户使用键盘快捷键来移动和调整窗口大小。 项目地址：https://github.com/rxhanson/Rectangle 1.9. uPic Mac图床客户端（Swift） uPic 是一款 Mac图床(文件)上传客户端，它可以将图片、各种文件上传到配置好的指定对象存储中，然后即时生成可供互联网访问的文件URL。支持图床： smms、 又拍云 USS、七牛云 KODO、 阿里云 OSS、 腾讯云 COS、微博、Github、 Gitee、 Amazon S3、自定义上传接口。无论是本地文件、或者屏幕截图都可自动上传，菜单栏显示实时上传进度。上传完成后文件链接自动复制到剪切板，返回的URL链接格式可以选择：普通 URL、HTML 或者 Markdown，非常灵活，推荐使用，比iPic强大！ 项目地址：https://github.com/gee1k/uPic 1.10. OpenInTerminal 在当前目录打开终端（Swift） OpenInTerminal 是一款开发辅助工具，可以在当前位置打开终端。主要功能：在终端（或编辑器）中打开当前目录以及在终端（或编辑器）中打开选择的文件夹或文件。 支持的终端： iTerm, Hyper 和 Alacritty 支持的文本编辑：Visual Studio Code, VSCode Insiders, Atom, Sublime Text, VSCodium, BBEdit，TextMate，CotEditor，MacVim 和 JetBrains(AppCode, CLion, GoLand, IntelliJ IDEA, PhpStorm, PyCharm, RubyMine, WebStorm) 设置为打开新的窗口或者标签页 将已选择的文件或者访达窗口的路径拷贝到粘贴板 支持键盘快捷键 支持 Dark Mode 项目地址：https://github.com/Ji4n1ng/OpenInTerminal 1.11. MonitorControl 菜单栏显示器音量亮度调节（Swift） MonitorControl 是一款 macOS 菜单栏多显款器音量及亮度调节应用。相信很多 Mac 用户都是一台 MacBook 加一台外接显示器，但是你会发现 macOS 不能用键盘直接调节外接显款器的亮度和输出的音量。MonitorControl 的出现就是为了解决这个问题的，MonitorControl 不仅可以对外接屏的音量、亮度调节，还可以对外接屏的对比度进行调节，并可以自定义选择快捷键控制的类型，或是指定在某个屏幕启用这些功能，甚至连 ⇧Shift+⌥Option 这种微调音量控制都能支持。 项目地址：https://github.com/MonitorControl/MonitorControl 1.12. NetNewsWire RSS新闻订阅客户端（Swift） NetNewsWire 是一款开源免费的 RSS订阅器，支持Safari扩展程序，可轻松添加Feed订阅，支持通过Feedbin同步，共享到邮件，MarsEdit，Micro.blog，便笺，消息等，支持AppleScript。 开源项目：https://github.com/Ranchero-Software/NetNewsWire 1.13. Karabiner-Elements 键盘键位修改神器（Swift） karabiner-elements 一款开源的 macOS 键盘修改神器。可以将键盘上的某个键位映射为任意指定的其他键位。可以仅特定/同时对连接到 Mac 的键盘设备生效。支持虚拟键盘（ANSI, ISO, JIS）等。支持设置多套偏好设置，可根据场景切换使用 项目地址：https://github.com/pqrs-org/Karabiner-Elements 1.14. CotEditor 开源免费的文本编辑器（Swift） CotEditor 是一款针对 macOS 开发的轻量级代码编辑器。CotEditor 启动非常快，支持 50 多种语言高亮，例如HTML、PHP、Python、Ruby、Markdown、Javascript等等。 项目地址：https://github.com/coteditor/CotEditor 1.15. Thor 通过快捷键快速打开应用（Swift） Thor 是一款 Mac 效率类应用，可以针对指定的应用设计设置快捷键，通过指定的快捷键快速打开应用和切换应用。 项目地址：https://github.com/gbammc/Thor 1.16. LyricsX 菜单栏及桌面歌词显示（Swift） LyricsX 是一款 Mac 桌面歌词及菜单栏歌词显示应用。可从网络自动搜索和下载当前播放歌曲的歌词并将其显示在桌面和菜单栏中，您可以自定义字体，颜色和位置，在状态菜单上调整歌词偏移，另外可以拖放导入歌词以及导出歌词文件。支持 iTunes、Spotify、Vox、Audirvana、Swinsian 等音乐播放器。歌词来源：网易云音乐、QQ音乐、酷狗音乐、虾米音乐、天天动听、歌词迷。 项目地址：https://github.com/ddddxxx/LyricsX 1.17. Pock 在TouchBar中显示Dock栏图标（Swift） Pock 是一款可以将macOS Dock栏图标映射到触摸栏中显示工具。程序还附带了一些简约的小部件，比如时间，Wifi，电量、亮度控制、声音控制、正在播放等。 项目地址：https://github.com/pigigaldi/Pock 1.18. Stats 菜单栏系统监视器（Swift） Stats 是一款macOS菜单栏系统监视工具。可以帮助您实时监视：CPU利用率、GPU利用率、内存使用情况、磁盘利用率、传感器信息（温度/电压/功率）、电池电量、网络使用等信息。 项目地址：https://github.com/exelban/stats 1.19. Gifski 从视频中提取gif动图（Swift） Gifski for Mac 是一款可以将视频转换为GIF动画的应用。Gifski 支持 macOS 支持的所有视频格式（.mp4/.movH264/HEVC/ProRes 等等）。使用方法简单：只需将视频拖放到主界面，然后裁切需要时长的视频，设置尺寸（可以自定义宽度和高度）、FPS、质量，点击转换即可。 项目地址：https://github.com/sindresorhus/Gifski 1.20. Retroactive 解锁MacOS软件系统限制（Swift） Retroactive (解印) 可让您在 macOS Catalina (10.15.x) 上运行iTunes，iPhoto和Aperture。还可以在 macOS Mojave (10.14.x) 解封 Xcode 11.4.1。 macOS Mojave 或macOS High Sierra 上解锁 Final Cut Pro 7，Logic Pro 9 或者修复 iWork '09。 项目地址：https://github.com/cormiertyshawn895/Retroactive 1.21. PicGo 跨平台图床软件 PicGo 是一款强大的mac图床工具，默认支持微博图床、七牛图床、腾讯云COS、又拍云、GitHub、SM.MS、阿里云OSS、Imgur，方便不同图床的上传需求。支持5种默认剪贴板链接格式：Markdown/html/url/ubb/自定义链接格式，让你的文本编辑游刃有余。2.0版本开始支持插件系统 项目地址：https://github.com/Molunerfinn/PicGo 1.22. Stretchly 休息提醒工具 Stretchly 是一款免费开源的 Mac 休息提醒工具。默认情况下，每10分钟有20秒的小憩，每30分钟有5分钟的长休息（在2个小憩之后）。您可以设置小憩与休息间隔、提醒声音、界面主题样式以及提醒模式，并提供可选的不可跳过休息模式。 项目地址：https://github.com/hovancik/stretchly 1.23. Terminus 支持SSH的mac终端模拟器 Terminus 是一个高度可配置的终端模拟器，适用于Windows，macOS和Linux。 主题和配色方案，完全可配置的快捷键，仿chrome标签页，保存最近打开的标签，集成的SSH客户端和连接管理器，完整的Unicode支持，包括双宽字符 项目地址：https://github.com/Eugeny/terminus 1.24. Electerm 终端模拟器/ssh/sftp客户端 Electerm 是一款集终端模拟器、文件管理器、ssh远程连接、sftp客户端为一体的工具（类似于xshell），允许双击直接编辑远程文件（小文件），使用内置编辑器编辑本地文件，使用publickey +密码验证，Zmodem（rz，sz），还有自定义终端样式，全局/会话代理，将书签/主题/快速命令同步到github secret gist等功能。 项目地址：https://github.com/electerm/electerm 1.25. 洛雪音乐 全网音乐播放下载工具 洛雪音乐 for mac是一款全网免vip无损音乐歌曲下载工具，LuoXue Music支持免vip下载歌典的平台：QQ音乐无损音乐下载、酷狗音乐无损音乐下载、酷我音乐无损音乐下载、百度音乐无损音乐下载、网易云音乐无损歌典下载。lx music，你值得拥有！ 项目地址：https://github.com/lyswhut/lx-music-desktop 1.26. KeeWeb 跨平台密码管理器 KeeWeb for Mac是一款非常赞的密码管理器，KeeWeb与KeePass兼容的而且是跨平台的。KeeWeb在您浏览网站或者使用需要输入密码的应用中可以帮您自动填写已存储的密码。拥有密码生成器，支持密码生成规则，可以帮您生成最安全的密码！ 项目地址：https://github.com/keeweb/keeweb 1.27. Buttercup 跨平台密码管理器 Buttercup for Mac 是一款精美简单的密码管理器，旨在帮助您管理凭据。Buttercup使用非常强大的加密功能，以一个主密码保护您的敏感信息-随时为每个服务使用更强大，更复杂的密码，并让Buttercup安全地存储它们，支持自定义字段功能！Buttercup将跨平台提升到了新的高度，支持Windows、macOS、Linux、iOS、Android和浏览器插件 项目地址：https://github.com/buttercup 1.28. Listen 付费VIP音乐免费听 Listen 1 是一款 Mac 全网音乐播放器。可以搜索和播放来自网易云音乐，虾米音乐，酷狗音乐，酷我音乐，哔哩哔哩，咪咕音乐，QQ音乐七个主流音乐网站平台的付费VIP歌曲，让你的曲库更全面。并支持收藏功能，方便的创建自己的歌单。 项目地址：https://github.com/listen1/listen1_desktop 1.29. Mark Text Markdown编辑器 Mark Text for mac是一款所输即所见的markdown编辑器，摒弃了众多 Markdown 编辑器左边写作右边预览的写作方式，巧妙的将编辑和预览融为一体。极速渲染编辑页面，带来流畅的书写体验。生成的 Markdown 可以复制到任何支持 Markdown 格式的社区、网站。可以导出 HTML 和 PDF 格式文件。支持六种皮肤风格，支持多种编辑模式：源代码模式、打字机模式、专注模式。 项目地址：https://github.com/marktext/marktext 1.30. Motrix 全能的下载工具 Motrix for mac版是一款全能的下载工具。支持 HTTP下载、FTP下载、BT下载下载、磁力链下载、百度网盘资源下载。Motrix 也是采用了「Aria 2」作为核心，所以下载速度、多线程等能力与其他下载工具几乎一致。 项目地址：https://github.com/agalwood/Motrix 1.31. NTFSTool NTFS硬盘读写工具 NTFS Tool For Mac 是一款为 macOS 提供 NTFS 读写支持的软件。 支持NTFS磁盘读写、挂载、推出、管理等功能。它的界面简洁易用，希望这款工具能够为你的工作和生活带来便利。NTFS Tool 是一款纯净版的NTFS硬盘读写工具。 项目地址：https://github.com/ntfstool/ntfstool 1.32. SwitchHosts! mac hosts修改工具 SwitchHosts! 是一个管理切换编辑Mac系统hosts的工具。支持编辑mac hosts文件，自定义以及添加多个hosts文件配置，备份hosts文件。 项目地址：https://github.com/oldj/SwitchHosts 1.33. magnetW 磁力聚合搜索工具 magnetW 是一款开源的Mac磁力链接聚合搜索工具。磁力搜 For magnetW通过关键字词搜索时实反馈搜索结果，包含大小，时间，来源，避免下载葫芦娃。可以配合 webtorrent 进行在线播放（webtorrent加载资源得等待几分钟），可以配合Folx、迅雷不限速进行下载。 项目地址：https://github.com/xiandanin/magnetW 1.34. draw.io 流程图绘制应用 draw.io for Mac 是一款免费的跨平台绘图工具。可以创建流程图、组织架构图、UML、ER图、泳道图、网络拓朴图、思维导图等等。内置丰富的模板和控件库供挑选使用，还可以导入组件。支持Google Dirve，One Drive， Dropbox和本地存储，支持将流程图导出为多种格式，比如 pdf/svg/html 等，提供 Chrome 插件。 项目地址：https://github.com/jgraph/drawio-desktop "},"Mac/FRP客户端配置.html":{"url":"Mac/FRP客户端配置.html","title":"FRP客户端配置","summary":"macOS 系统配置 FRP 客户端，并实现开机自启动","keywords":"","body":"1.1. 安装1.2. 配置自启动1.2.1. 1. 创建 plist 配置文件1.2.2. 2. 添加到自启动1.1. 安装 地址 下载 darwin_arm64（Apple 芯片）或 darwin_amd64 (Intel 芯片) 版本，解压后编辑 frpc.ini 文件： [common] tls_enable = true server_addr = xxxx server_port = xxxx token = xxxx [vnc] type = tcp local_ip = 0.0.0.0 local_port = 5900 remote_port = xxxx [ssh] type = tcp local_ip = 0.0.0.0 local_port = 22 remote_port = xxxx 运行命令：./frpc -c frpc.ini 即可 需注意放开服务器的对应端口，并检查端口是否被其他程序占用 1.2. 配置自启动 使用 macOS 的 launchd 实现开机自启动 如果需要 root，并且是需要用户登陆后才能运行，把 plist 放在 ~/Library/LaunchAgents/ 如果需要 root，并且不需要用户登陆后都能运行，把 plist 放在 /Library/LaunchDaemons/ 1.2.1. 1. 创建 plist 配置文件 打开终端执行： sudo touch /Library/LaunchDaemons/frpc.plist 使用代码编辑软件或 vim 打开 frpc.plist 并填写以下内容： Label frpc ProgramArguments frpc 绝对路径 -c frpc.ini 绝对路径 KeepAlive RunAtLoad 1.2.2. 2. 添加到自启动 为 frpc.plist赋予权限： sudo chown root /Library/LaunchDaemons/frpc.plist 加载配置到系统使配置生效，随系统自启动： sudo launchctl load -w /Library/LaunchDaemons/frpc.plist 如后续需关闭随系统自启动，执行： sudo launchctl unload -w /Library/LaunchDaemons/frpc.plist "},"Mac/Markdown.html":{"url":"Mac/Markdown.html","title":"Markdown","summary":"Markdown 语法","keywords":"","body":"1. 目录11.1. Heading level 2 This is the first list item. Here's the second list item. A blockquote would look great below the second list item. And here's the third list item. Open the file. Find the following code block on line 21: Test Update the title to match the name of your website. Open the file containing the Linux mascot. Marvel at its beauty. Close the file. First item Second item Third item Indented item Indented item Fourth item This word is bold. This word is italic. This is a regular paragraph. Foo This is another regular paragraph. 这是一个链接 Markdown语法。 这是一个链接 Markdown语法。 https://markdown.com.cn fake@example.com I love supporting the EFF. This is the Markdown Guide. See the section on code. link At the command prompt, type nano. Use `code` in your Markdown file. { \"firstName\": \"John\", \"lastName\": \"Smith\", \"age\": 25 } { \"firstName\": \"John\", \"lastName\": \"Smith\", \"age\": 25 } 1. 目录1 1.1. Heading level 2 The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan. Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. Italicized text is the cat's meow. Italicized text is the cat's meow. AcatmeowThis text is really important. First line with the HTML tag after. And the next line. Syntax Description Header Title Paragraph Text Syntax Description Test Text Header Title Here's this Paragraph Te|xt And more Heading IDs 世界是平坦的 我们现在知道世界是圆的。 [x] Write the press release [ ] Update the website [ ] Contact the media http://www.example.com http://www.example.com 页面内跳转 点击时的区域标题 echo \"hello shell\" echo \"hello python\" "},"Mac/zsh.html":{"url":"Mac/zsh.html","title":"zsh","summary":"Mac终端zsh常用命令","keywords":"","body":"1.1.1. cd 切换到目录1.1.2. ls 查看文件与目录1.1.3. cp 复制文件1.1.4. mv 移动文件或目录、更名1.1.5. rm 删除文件或目录1.1.6. 示例1.1.7. grep 分析一行的信息1.1.8. cat1.1.9. chmod 更改文件权限1.1.10. chown 更改文件所有者1.1.11. chgrp1.1.12. vim1.2. FAQ1.2.1. oh-my-zsh git 慢/卡顿问题解决1.1.1. cd 切换到目录 示例 cd /root/Docements # 切换到目录/root/Docements cd ./path # 切换到当前目录下的path目录中，一个点“.”表示当前目录 cd ../path # 切换到上层目录中的path目录中，两个点“..”表示上一层目录 1.1.2. ls 查看文件与目录 参数 -l : 列出长数据串，包含文件的属性与权限数据等 -a : 列出全部文件，连同隐藏文件(开头为.的文件)一起列出来(常用) -d : 仅列出目录本身，而不是列出目录的文件数据 -h : 将文件容量以较易读的方式(GB，kb等)列出来 -R : 连同子目录的内容一起列出(递归列出),等于该目录下所有的文件都会显示出来 注意 : 这些参数可以组合使用 1.1.3. cp 复制文件 参数 -a ：将文件的特性一起复制 -p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份 -i ：若目标文件已经存在时，在覆盖时会先询问操作的进行 -r ：递归持续复制，用于目录的复制行为 -u ：目标文件与源文件有差异时才会复制 1.1.4. mv 移动文件或目录、更名 参数 -f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件已经存在，就会询问是否覆盖 -u ：若目标文件已经存在，且比目标文件新，才会更新 示例 mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中 mv file1 file2 # 把文件file1重命名为file2 1.1.5. rm 删除文件或目录 参数 -f ：就是force的意思，忽略不存在的文件，不会出现警告消息 -i ：互动模式，在删除前会询问用户是否操作 -r ：递归删除，最常用于目录删除，它是一个非常危险的参数 1.1.6. 示例 rm -i file # 删除文件file，在删除之前会询问是否进行该操作 rm -fr dir # 强制删除目录dir中的所有文件 1.1.7. grep 分析一行的信息 参数 -a ：将binary文件以text文件的方式查找数据 -c ：计算找到‘查找字符串’的次数 -i ：忽略大小写的区别，即把大小写视为相同 -v ：反向选择，即显示出没有‘查找字符串’内容的那一行 file 1.1.8. cat 1.1.9. chmod 更改文件权限 1.1.10. chown 更改文件所有者 1.1.11. chgrp 1.1.12. vim 1.2. FAQ 1.2.1. oh-my-zsh git 慢/卡顿问题解决 git config --add oh-my-zsh.hide-dirty 1 git config --add oh-my-zsh.hide-status 1 "},"Mac/Homebrew.html":{"url":"Mac/Homebrew.html","title":"Homebrew","summary":"Homebrew 是 macOS、Linux 下的一个包管理工具","keywords":"","body":"1. Homebrew1.1. 安装卸载软件1.2. 升级软件相关1.3. 清理相关1.4. 源管理1.4.1. 查看源1.4.2. 替换为清华源1.4.3. 替换为阿里源1.4.4. 重置为官方源1. Homebrew Homebrew 是一款自由及开放源代码的软件包管理系统，用以简化 macOS 和 linux 系统上的软件安装过程。它拥有安装、卸载、更新、查看、搜索等很多实用的功能，通过简单的一条指令，就可以实现包管理，十分方便快捷。 Homebrew 主要有四个部分组成: | 名称 | 备注 | |------------------|---------------------------------| | brew | Homebrew 源代码仓库 | | homebrew-core | Homebrew 核心软件仓库 | | homebrew-bottles | Homebrew 预编译二进制软件包 | | homebrew-cask | 提供 macOS 应用和大型二进制文件 | 1.1. 安装卸载软件 brew --version 或者 brew -v 显示brew版本信息 brew install 安装指定软件 brew uninstall 卸载指定软件 brew list 显示所有的已安装的软件 brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾 brew search /text/ 使用正则表达式搜软件 brew info 显示指定软件信息 brew reinstall 重新安装指定软件，先卸载后安装 brew install --build-from-source 源码安装指定软件，可以给定指定参数 brew commands 列出所有可用命令 1.2. 升级软件相关 brew update 自动升级homebrew （从github下载最新版本） brew outdated 检测已经过时的软件 brew upgrade 升级所有已过时的软件，即列出的以过时软件 brew upgrade 升级指定的软件 brew pin 禁止指定软件升级 brew unpin 解锁禁止升级 brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包 brew edit 编辑软件，不会的情况下慎用 brew tap 列出本地资源仓库，其中 homebrew 是默认仓库，其它都是第三方仓库 brew tap 添加第三方仓库，命名的规则按照github来定的。使用 brew untap 删除仓库 brew deps 查看指定软件依赖于哪些软件 brew uses 查看指定软件被哪些软件所依赖 1.3. 清理相关 homebrew 在升级软件时候不会清理相关的旧版本，在软件升级后我们可以使用如下命令清理 brew cleanup -n 列出需要清理的内容 brew cleanup 清理指定的软件过时包 brew cleanup 清理所有的过时软件 brew unistall 卸载指定软件 brew unistall --force 彻底卸载指定软件，包括旧版本 通过brew安装的文件会自动设置环境变量，所以不用担心命令行不能启动的问题。 1.4. 源管理 1.4.1. 查看源 查看 brew.git 当前源 cd \"$(brew --repo)\" && git remote -v 查看 homebrew-core.git 当前源 cd \"$(brew --repo homebrew/core)\" && git remote -v 1.4.2. 替换为清华源 替换 brew.git 源 git -C \"$(brew --repo)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git 替换 homebrew-core.git 源 git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git 替换 homebrew-cask.git 源 git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git zsh 替换 brew bintray 镜像 echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' >> ~/.zshrc 更新配置 source ~/.zshrc bash 替换 brew bintray 镜像 echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' >> ~/.bash_profile 更新配置 source ~/.bash_profile 刷新源 brew update 1.4.3. 替换为阿里源 替换 brew.git 源 git -C \"$(brew --repo)\" remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 替换 homebrew-core.git 源 git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git 替换 homebrew-cask.git 源 git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-cask.git zsh 替换 brew bintray 镜像 echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' >> ~/.zshrc 更新配置 source ~/.zshrc bash 替换 brew bintray 镜像 echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' >> ~/.bash_profile 更新配置 source ~/.bash_profile 刷新源 brew update 1.4.4. 重置为官方源 重置 brew.git 源 git -C \"$(brew --repo)\" remote set-url origin https://github.com/Homebrew/brew.git 重置 homebrew-core.git 源 git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://github.com/Homebrew/homebrew-core.git 替换 homebrew-cask.git 源 git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://github.com/Homebrew/homebrew-cask.git zsh 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置 vi ~/.zshrc 更新配置 source ~/.zshrc bash 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置 vi ~/.bash_profile 更新配置 source ~/.bash_profile 刷新源 brew update "},"Mac/Xcode.html":{"url":"Mac/Xcode.html","title":"Xcode","summary":"Xcode 相关","keywords":"","body":"1.1. 错误处理1.1.1. This application's application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed1.2. 查看 iPA entitlements1.3. Xcode Build1.4. LLDB1.4.1. 命令1.4.2. 参考1.1. 错误处理 1.1.1. This application's application-identifier entitlement does not match that of the installed application. These values must match for an upgrade to be allowed 原因：这个项目App已经存在这个真机上了，这个App是旧的identifier运行的。 解决方法：Xcode --->Window ---> Devices ---> 自己的真机 ---> installed Apps ----> 删除这个App ----> 重新运行 1.2. 查看 iPA entitlements codesign -d Demo_netease2.app --entitlements - 1.3. Xcode Build https://help.apple.com/xcode/mac/current/#/itcaec37c2a6 Xcode 常见 CLI 工具 Create an archive of the framework or library for each platform you wish to support by entering one xcodebuild command for each platform’s generic run destination. To build a macOS variant of your framework built for UIKit, pass Mac Catalyst as the variant argument. xcodebuild archive [-project ] -scheme -destination \"generic/platform=[,arch=][,variant=]\" [-configuration ] [-archivePath ] Create an XCFramework which includes each variant of the framework or library by entering an xcodebuild command with the -create-xcframework option in Terminal: xcodebuild -create-xcframework -framework [-framework ...] -output xcodebuild -create-xcframework -library [-headers ] [-library [-headers ]...] -output 1.4. LLDB 1.4.1. 命令 bt tb po 1.4.2. 参考 http://southpeak.github.io/2015/01/25/tool-lldb/ "},"Linux/":{"url":"Linux/","title":"Linux","keywords":"","body":"1. Introduction1. Introduction "},"Linux/WSL.html":{"url":"Linux/WSL.html","title":"WSL","summary":"WSL","keywords":"","body":"1.1. WSL2 支持 ipv61.2. WSL2 启用 systemd1.3. WSL2 启用 sshd1.1. WSL2 支持 ipv6 系统版本 Windows 11 22H2 及以上 Microsoft Store 里下载最新的 Windows Subsystem for Linux 确认 wsl --version 在 1.0 以上 使用 Hyper-V 创建 WSLBridge 的外部虚拟交换机来给 WSL2 用 在用户目录 %USERPROFILE% 下面创建一个配置文件 .wslconfig，格式如下： [wsl2] networkingMode=bridged # 桥接模式 vmSwitch=WSLBridge # 你想使用的网卡 ipv6=true # 启用 IPv6 输入 wsl --shutdown && wsl 重启 WSL2 1.2. WSL2 启用 systemd 使用最新版本 wsl 运行以下命令： echo -e \"[boot]\\nsystemd=true\" | sudo tee -a /etc/wsl.conf 输入 wsl --shutdown && wsl 重启 WSL2 输入 ps --no-headers -o comm 1 是否返回 systemd 判断 wsl 是否已启用 systemd 1.3. WSL2 启用 sshd "},"Git/":{"url":"Git/","title":"Git","keywords":"","body":"1. Introduction1. Introduction "},"Git/Git-Manual.html":{"url":"Git/Git-Manual.html","title":"Git Manual","keywords":"","body":"1. Git Manual1.1. Git 简介1.2. Git 使用1.2.1. 更新 Git 缓存1.2.2. 分支与标签1.2.3. 远程仓库1.3. Git 规范1.3.1. Git 分支1.3.2. Git 命令行操作流程1.3.3. TAG 命名1. Git Manual 1.1. Git 简介 Git 是目前世界上最先进的分布式版本控制系统。SVN 是集中式版本控制系统，版本库是集中放在中央服务器的。Git 是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库。Git 配置用户标识： $ git config --global user.name \"Gh.Wang\" $ git config --global user.email \"1299927852@qq.com\" 1.2. Git 使用 选择一个空目录，路径最好不包含中文，然后使用 git init 可以把这个目录变成 Git 可以管理的仓库，只会可以用 git add 命令将文件添加到仓库暂存区中，然后可以用 git commit 提交到版本库分支中 $ git add readme.txt $ git commit -m \"wrote a readme file\" 之后可以使用给 git status 查看结果，当前是否有新的更改以及更改是否提交，如果被修改了可以用 git diff 查看文件修改前后的不同，选择是否要保留更改。如果选择放弃更改使用命令 git checkout -- file 可以丢弃工作区的修改，同时命令 git reset HEAD 可以把暂存区的修改撤销掉，重新放回工作区。git log 命令可以显示从最近到最远的提交日志，可以加上 --pretty=oneline 让信息在一行显示。之后进行版本回退有两种 方式 用 HEAD 表示当前版本，也就是最新的提交版本，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，以此类推，如果较多可以用 HEAD~n，然后使用命令 $ git reset --hard HEAD^ 回退。 直接使用 $ git reset --hard 加上版本号，一般输入版本号的前几位就可以了。 在版本回溯中，git 使用指针，将指针头指向真正应用的版本，当需要更改的时候只需要移动指针就可以了。 如果要删除某个文件的话就直接使用 rm 命令, 不过此时并没有在版本库中删除，如果确实要从版本库中删除需要使用 $ git rm test.txt $ git commit -m \"remove test.txt\" 如果误删，则可以使用 git checkout -- test.txt 恢复到最新版本。 1.2.1. 更新 Git 缓存 更新缓存 git rm -r --cached . 1.2.2. 分支与标签 创建并切换分支:$ git checkout -b name 查看当前分支:git branch 切换分支:git checkout name 合并指定分支到当前分支:git merge 删除分支:git branch -d 新建一个标签:git tag 指定标签信息:git tag -a -m \"blablabla...\" 查看所有标签:git tag 1.2.3. 远程仓库 首先需要创建 SSH Key，使用命令： $ ssh-keygen -t rsa -C \"1299927852@qq.com\" 可以在用户目录下看到.ssh 目录，目录中有 id_rsa 和 id_rsa.pub 两个文件，其中第一个是私钥，第二个是公钥，我们一般用的就是公钥。在 github 的 setting 的 ssh keys 界面加入自己的公钥，之后电脑就可以往 github 上推送了。 添加远程库，使 github 上的远程库与本地库同步，使用命令： $ git remote add origin git@gitee.com:wanggh8/resume.git 第一次可以使用 git push -u origin master 命令，实际上是把当前分支 master 推送到远程。之后可以直接使用命令 git push origin master 从远程库克隆时，使用 git pull git@gitee.com:wanggh8/resume.git 使用码云时大部分只需要将 github 替换成 gitee 就可以了，可以同时关联两个远程库，但名字应该不同。 1.3. Git 规范 1.3.1. Git 分支 master 存储正式发布历史的主分支，不能直接在 master 上进行修改代码和提交。 dev 作为开发分支，开发完成需要提交测试的功能合并到该分支，共同维护的开发分支。 release 上线前的 预览分支，可用于测试人员测试要上线的正式版，测试完成后 PR 到 master。 feature 基于 dev 创建的临时分支，用于开发新功能或新模块，在本地与 dev 合并后 PR 到 dev 分支。 1.3.2. Git 命令行操作流程 // 本地分支 local git pull origin local git add . git commit -m '' // 这里需写明这次提交的改动说明（必须提交），以便以后回退找到对应的指针 git push origin local git checkout dev git pull origin dev git checkout local // 切换到自己的分支 git merge dev // 有冲突解决冲突，让冲突发生在自己本地分支 git checkeout dev git merge local // 更新代码到 dev 分支 git add . git commit -m \"merge local 实现的功能\" git push origin dev 1.3.3. TAG 命名 采用三段式＋日期，v 版本. 里程碑. 序号，如 v1.2.1-20200801 Bug 修复并上线，修改第 3 位 架构升级或重大调整，修改第 2 位 新功能上线或者模块调整，修改第 2 位 "},"Git/Git-LFS.html":{"url":"Git/Git-LFS.html","title":"Git LFS","summary":"Git LFS","keywords":"","body":"1. Git LFS1.1. 使用目的1.2. 安装1.2.1. Linux1.2.2. Mac1.2.3. Windows1.3. 使用1. Git LFS Git LFS 是 Github 开发的一个 Git 的扩展，用于实现 Git 对大文件的支持 1.1. 使用目的 在游戏开发过程中,设计资源占用了很大一部分空间. 像 png、psd 等文件是二进制 (blob) 的,体积也很庞大。但 git 的 diff/patch 等是基于文件行的。对于二进制文件来说， git 需要存储每次 commit 的改动。每次当二进制文件修改，发生变化的时候. 都会产生额外的提交量，导致 clone 和 pull 的数据量大增，在线仓库的体积也会迅速增长。 LFS (Large File Storage) 就是为了解决这一问题而产生的工具。它将你所标记的大文件保存至另外的仓库，而在主仓库仅保留其轻量级指针。那么在你检出版本时，根据指针的变化情况下更新对应的大文件，而不是在本地保存所有版本的大文件。 1.2. 安装 注意：安装 Git LFS 需要 Git 的版本不低于 1.8.5 1.2.1. Linux curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash ` sudo apt-get install git-lfs git lfs install 1.2.2. Mac brew install git-lfs git lfs install 1.2.3. Windows 下载安装 windows installer 运行 windows installer 在命令行执行 git lfs install 1.3. 使用 执行 git lfs install 开启lfs功能 使用 git lfs track 命令进行大文件追踪 例如 git lfs track \"*.png\" 追踪所有后缀为 png 的文件 使用 git lfs track 查看现有的文件追踪模式 提交代码需要将 .gitattributes 文件提交至仓库. 它保存了文件的追踪记录 提交后运行 git lfs ls-files 可以显示当前跟踪的文件列表 将代码 push 到远程仓库后，LFS 跟踪的文件会以『Git LFS』的形式显示: clone 时 使用 git clone 或 git lfs clone 均可 "}}